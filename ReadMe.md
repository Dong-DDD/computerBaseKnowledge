## java基础

### 1.面向过程和面向对象

> 面向过程就是将实现分为多个步骤，按照步骤顺序依次实现。
>
> 面向对象注重模块化和功能的抽取。
>
> 比如实现一个五子棋的下棋程序，面向过程的开发顺序是
>
> > 黑子下-->判断机制-->绘制页面-->白子下-->判断机制-->黑子下
>
> 而对于面向对象而言，会将整个程序拆分为
>
> > 棋子、绘制界面、判断机制多个功能然后分别进行实现即可
>
> 对比
>
> > 面向过程的效率更高
> >
> > 面向对象的可复用性、可维护性更高

### 2.重载和重写

> 重载
>
> > 发生在同一个类中，具体是多个方法具有相同的方法名，但是返回值、参数列表不同；
>
> 重写
>
> > 需要基于继承来实现，主要是子类方法在不改变父类方法的前提下，在父类方法的基础上添加新的功能。
> >
> > 因为是基于继承实现的，所以子类中的重载方法的访问修饰符不能比父类方法更加宽松

### 3.面向对象的三大特性——封装、继承、多态

> 封装
>
> > 封装就是将一个对象的属性和方法私有化，同时提供一些外部访问的接口，其实现细节不向外暴露。
> >
> > 比如User类中的age属性，只能通过set和get方法来设置和获取该属性
>
> 继承
>
> > 继承的根本目的是复用现有代码。利用现有类的定义作为基础，来建立新的类，新建立的类具有基础类的所有属性和方法，并且可以增加新的属性和方法。
> >
> > 1. 对于父类的私有属性和方法，子类只能拥有，不能访问。
> > 2. 子类可以增加新的方法和属性
> > 3. 子类可以用自己的方式实现父类方法
>
> 多态
>
> > 简单来说，多态就是同一行为的不同表现形式。
> >
> > 多态需要依托继承来实现，最简单的例子`List<> = new ArrayList<>();`就是多态实现的。
> >
> > 多态就是在程序运行阶段才能确定。
> >
> > 多态实现的基本条件：
> >
> > 1. 继承或实现
> >
> >    多态中必须存在于有继承或实现的子类和父类之间；
> >
> > 2. 方法的重写
> >
> >    子类存在对父类方法的重写，因此在调用这些方法时会调用子类的方法；
> >
> > 3. 父类引用指向子类对象`Array<Integer> list = new ArrayList<>();`

### 4.String、StringBuffer、StringBuilder

> String
>
> > String的底层是由final 修饰的 byte数组实现的，所以在初始化的时候就一定确定了长度。
> >
> > 平时进行的字符串相加的操作，实质上是先重新申请一块内存区域，然后将相加的字符串放到新的地址中，然后再指向新的地址。
> >
> > 因为字符串的拼接涉及到地址的重新指向，所以效率比较低，只适合小容量的字符串操作。
>
> StringBuffer和StringBuilder
>
> >都是继承自AbstractStringBuilder，所以它们的底层都是由byte数组实现的。
> >
> >因为没有使用final关键字修饰byte数组，所以它们的长度是可以增加的，默认初始容量是16，当其长度增加到阈值时，会自动扩充容量，阈值一般是现有容量的75%，扩充方式一般是直接扩充到现有容量的2倍。
> >
> >如果携带参数进行初始化的话，那么容量被设为 参数长度+16
>
> StringBuffer和StringBuilder区别
>
> >两者唯一存在的区别就是StringBuffer中的方法都使用synchronized关键字进行了修饰，所以是线程安全的。
> >
> >也正是因为StringBuffer是线程安全的，所以其效率没有StringBuilder高

### 5.自动装箱和自动拆箱

> 自动装箱和自动拆箱实质是基本数据类型和对于的包装类型的转换。
>
> > 自动装箱就是基本数据类型转换为对应的包装类型
> >
> > 自动拆箱就是包装类型转换为对应的基本数据类型
>
> 这样的话也带来的一些问题
>
> > 1. Integer(num)
> >
> >    > 当num在`[-128,127]`之间时，会存在指定的区域内，此时两个Integer类型的变量的地址值是相同的。
> >    >
> >    > 若不在这个范围内的话，会重新创建申请一个区域来存储，所以地址值是不同的

### 6.java的无参构造器的作用

> 主要作用是应对子类的使用。
>
> 在调用子类的构造方法之前，如果没有使用super关键字指定父类的构造方法的话，将会默认调用父类的无参构造方法，如果父类没有无参构造方法的话，在编译时会报错。
>
> 如果没有在父类方法中设置任何的构造方法的话，将会默认生成无参构造方法，

### 7.接口和抽象类

> 接口
>
> >1. 接口中可以包含变量和方法
> >2. 一个方法可以实现多个接口
>
> 抽象类
>
> >1. 抽象类只能被继承，不能被实例化
> >2. 一个方法只能继承一个抽象类
> >3. 因为抽象类需要被继承，所以抽象类的访问权限只能设为public或protected，不能设为private
> >4. 包含抽象方法的类一定是抽象类，但抽象类不一定包含抽象方法
> >5. 子类在继承抽象类后，必须实现父类的方法，否则子类也必须被定义为抽象类
> >6. 抽象类中可以包含构造方法，但是构造方法不能被实例化，只能供给子类调用。

### 8.对象实例和对象引用

>对象实例
>
>>使用new关键字创建对象实例，对象实例存储在堆内存中
>
>对象引用
>
>>对象引用指向对象实例，存储在栈内存中。
>
>一个对象实例可以存在多个对象引用指向它，但是一个对象引用只能指向一个对象实例。

### 9.实例方法和静态方法

>实例方法
>
>>实例方法只能使用  类.方法名 进行调用
>>
>>访问无限制
>
>静态方法
>
>>静态方法可以使用  类.方法名  或 对象名.方法名  进行调用
>>
>>只能访问类中的静态成员，不能访问实例对象

### 10.==和equals

>==
>
>> 对于基本数据类型而言，==比较的是值；
>>
>> 对于引用类型而言，==比较的是地址；
>
>equals
>
>> 对于覆盖了equals的类型，equals比较的是值
>>
>> 对于没有覆盖的equals的类型，equals的作用和==相同

### 11.两个对象的hashcode相同，equals的结果是true吗？两个对象使用equals的结果为true，那么hashcode相同吗？

>hashcode是在存储对象时，使用哈希函数计算对象得到的值。
>
>因为涉及到了哈希函数，所以就会存在哈希碰撞问题。所以难免会出现两个对象通过哈希函数计算得到的值相同，此时就涉及到了equals的使用。
>
>若出现了哈希碰撞问题，使用equals判断已经存在的对象是否和当前对象相等，相等的话不进行任何操作；
>
>不相等的话，则向后移动。
>
>因此，
>
>> 当两个对象的hashcode相同，只能证明出现了哈希碰撞，不能代表两个对象的equals结果是true
>>
>> 两个对象使用equals的结果为true，那么计算得到的hashcode一定相同

### 12.Math.round()方法

>round方法的返回值有两种，分别是int和long。
>
>当参数大于或等于返回值的最大最小值时，其结果是返回值对应的最大最小值。
>
>其基本思想是逼近距离更近的整数，若相等的话，则近似到更大的值
>
>> 比如
>>
>> Math.round(11.5)=12
>>
>> Math.round(-11.5)=-11

### 13.深拷贝和浅拷贝

>浅拷贝：对于引用类型而言，浅拷贝就是指向同一个地址，所以一个引用类型变量改变了值，所有的变量的值都改变了
>
>深拷贝：对于引用类型而言，就是申请一个新的内存区域，然后将值复制过来，新的变量指向新的地址

### 14.final、finally、finalize

>final
>
>>final是一个关键字，可以修饰类、方法、变量；
>>
>>1. 使用final关键字修饰类
>>
>>   则该类不可被继承，类中的方法也被隐式的定义为final方法；
>>
>>   任意类中的private方法被隐式地定义为final方法
>>
>>2. 使用final关键字修饰方法
>>
>>   主要的原因有两个：
>>
>>   1. 把方法锁定，防止继承类修改其属性和作用
>>   2. 为了保持效率，早期的java版本会将final方法内嵌调用，现在已经不再使用这种方法
>>
>>3. 使用final关键字修饰变量
>>
>>   1. 对于基本数据类型而言，是为了初始化后，其值不再被改变
>>   2. 对于引用类型而言，是为了初始化后，不在指向其他的对象
>
>finally
>
>> 主要用在异常处理时。
>>
>> 无论异常是否出现，finally块中的代码均会执行
>
>finalize
>
>> 主要用在JVM的GC过程中。
>>
>> 1. 在进行GC的过程中，GC首先调用finalize方法，当下次调用GC时才会回收对象的内存。因此可以利用finalize方法在垃圾收集期间做一些其他的重要清理工作；
>>
>> 2. finalize被调用的情况
>>
>>    > 1. 所有的对象被GC时都会调用finalize
>>    > 2. 当程序退出时，会对其中的每一个对象调用finalize方法
>>    > 3. 显示的调用finalize方法
>>
>> 3. finalize方法属于Object类，因此所有的对象都可以调用finalize方法

### 15.反射机制

> 1. 反射机制
>
>    > 反射机制就是在运行状态下，任意一个类都可以调用当前类的所有的属性和方法
>    >
>    > 任意一个对象都可以调用当前类的所有属性和方法并可以修改其属性值。
>
> 2. 优点
>
>    > 1. 在运行时可以动态的获取类的实例，提高了灵活性
>    >
>    > 2. 可与动态编译相结合，如加载Mysql的驱动类
>
> 3. 缺点
>
>    > 因为反射需要解析字节码，所以效率比较低
>
> 4. 反射对象的获取
>
>    > 1. `Class.forName("类的全路径")`，如`Class.forName("com.mysql.jdbc.Driver")`
>    > 2. `类.class` ，如 `String.class`
>    > 3. `类.getClass()`，如`String str = new String("aaa"); str.getClass();`
>    > 4. 对于基本数据类型的包装类型而言，使用类似`Integer.Type`获取对象
>
> 5. API
>
>    > 1. Class类，是反射的核心类，可以用来获取类的属性、方法等信息
>    > 2. Field类，表示类的成员变量，可以用来获取和设置类中的属性值
>    > 3. Method类，表示类的方法或实例方法
>    > 4. Constructor类，表示类的构造方法
>
> 6. 反射的使用
>
>    ```java
>    public static void main(String[] args)
>    {
>        // 获取Class对象
>        Class<?> aClass = Class.forName("demo.Apple");
>        // 获取实例化对象
>        Object obj = aClass.getDeclaredConstructor().newInstance();
>        
>        // 获取方法 .getMethod("方法名",返回值类型.class)
>        Method setName = aClass.getMethod("setName",String.class);
>        Method setPrice = aClass.getMethod("setPrice",Double.class);
>        Method getPrice = aClass.getMethod("getPrice");
>        Method getName = aClass.getMethod("getName");
>        
>        // 执行方法 .invoke(实例化对象,参数值...)
>        setName.invoke(obj,"苹果11");
>        setPrice.invoke(obj,4599.00);
>        
>        System.out.println(getName(obj)+" "+getPrice(obj));
>    }
>    ```
>
> 7. 应用
>
>    > 1. JDK动态代理



## JAVA异常

### 1.`Exception`和`Error`的区别

> 1. java中的异常都由java.lang.Throwable类进行处理，Throwable类包含两个非常重要的子类：
>
>    1. Exception
>    2. Error
>
> 2. Exception类是指在程序中可以处理的异常，可以使用catch捕获异常，可以简单分为两类
>
>    1. 受检查的异常
>
>       必须要在程序中对其进行处理，包括除`RuntimeException`以外的所有异常，如`IOException`、`ClassNotFountException`等
>
>    2. 不受检查的异常
>
>       可以不进行处理，包括`RuntimeException`及其子类，如`NullPointException`、`ClassCastException`等
>
> 3. Error类是指程序中无法处理的类，catch也无法捕获，应当尽量避免出现；
>
>    如`OutOfMemory`、`StackOverFlowError`等

### 2.`try-catch-finally`

> 1. try用于捕获异常，后面可以接上若干个catch，如果没有catch的话，则必须要接上一个finally
> 2. catch用于处理异常
> 3. finally，无论出没出现异常，都会执行，但是在以下三种情况下不会执行
>    1. CPU被停止
>    2. 在try或catch块中使用System.exit(0)进行中断，且异常出现在该语句的后面
>    3. 程序所在的线程死亡

### 3.`throw`和`throws`的区别

> 1. 使用的位置不同，throw在方法中使用，throws在参数列表后面使用
>
> 2. throw一旦执行表示一定出现了异常，声明了throws但不代表一定会出现异常
>
> 3. throw需要用户自己捕获相关的异常，然后对其进行包装，最后再将包装后的异常抛出；
>
>    throws通常不需要显示的抛出异常，可由系统自动将捕获的异常抛给上级方法进行处理

## JAVA IO

### 1.`IO`流

> 1. 根据方向进行划分，可以分为输入流和输出流
> 2. 根据传输的基本单位进行划分，可以分为字节流和字符流
> 3. 根据功能进行划分，可以分为节点流和处理流
>
> 节点流
>
> >就是从或向一个特定的位置读写数据，直接与数据源相连
>
> 处理流
>
> >对节点流进行处理和封装，通过调用封装的流，实现数据传输工作。
> >
> >因为是将节点流进行了封装，消除了节点流之间的差异，并提供了更简单的输入输出方法

### 2.字节流和字符流

> 1. 字节流
>
>    > 以字节为基本的传输单位，比较适合传输二进制数据信息，如音视频数据等。
>    >
>    > 编码格式是`ASCII`编码
>    >
>    > 顶层抽象类使用`InputStream`和`OutputStream`
>    >
>    > `flush`方法是`OutputStream`中的空方法，有需要可以实现
>
> 2. 字符流
>
>    > 以字符为基本的传输单位，比较适合字符数据传输，如文本信息等。
>    >
>    > 编码格式是`Unicode`编码
>    >
>    > 顶层抽象类是`Writer`和`Reader`
>    >
>    > flush方法的作用是将转换为字节的字符流数据保存到磁盘
>    >
>    > 需要注意的是，字符流是由JVM转换字节流得到的，转换过程比较耗时

### 3.`BIO`、`NIO`、`AIO`的区别

> 1. `BIO`
>
>    >是最传统的IO方式，基于流模型实现。
>    >
>    >1. 实现方式：同步、阻塞
>    >
>    >2. 优点：代码简单，易于理解，适合连接数少且稳定的io传输
>    >3. 缺点：效率低，易成为瓶颈
>
> 2. `NIO`
>
>    >是jdk1.4提出的，提供了Channel、Selector、Buffer等新的抽象类
>    >
>    >1. 实现方式：同步、非阻塞
>    >2. 可以面向缓存、基于通道实现io操作
>    >3. 支持多路复用、同步非阻塞的io操作，同时提供了更加接近系统底层、效率更高的数据操作方式
>
> 3. `AIO`
>
>    >是NIO的升级版，jdk1.7提出的
>    >
>    >1. 实现方式：异步、非阻塞
>    >2. 异步IO是基于事件和回调机制实现的；
>    >3. 非阻塞意味着操作后就会立即返回不会阻塞在哪里，后台处理完成后，操作系统会通知相应的线程进行后续操作

### 4.同步、异步、阻塞、非阻塞

> 简单来说，IO操作包含两个具体的实现步骤：
>
> 1. IO请求
> 2. 实际的IO操作
>
> 第一个操作的不同实现是阻塞和非阻塞，第二个操作的不同实现是同步和非同步（实际上是内核和应用程序之间的交互模式）
>
> 阻塞：
>
> >客户端发出io请求，若此时没有资源可读或资源不可写，则等待资源，直至资源可以读或写
>
> 非阻塞：
>
> >客户端发出io请求，若此时没有资源可读或资源不可写，则直接返回
>
> 同步：
>
> > 当服务器接到请求，则持续等待或轮询处理器，查看当前操作是否就绪
>
> 异步：
>
> >当服务器接到请求，就去处理自己的事，直至接到操作系统传来IO处理完成的通知。
>
> 同步阻塞：
>
> >当服务器接收到客户端的一个请求后，就创建一个线程对其进行处理。
> >
> >一直盯着水壶，等待水烧开
>
> 异步阻塞：
>
> >客户端发出请求后，就一直等着请求完成的通知
> >
> >一直听着水壶的声音，同时做其他的事情
>
> 同步非阻塞：
>
> >客户端发出请求后，就将请求注册到多路复用器上，当多路复用器轮询到该请求时才会处理该请求。
> >
> >时不时的来看一下水壶，检查水是否烧开，但是不做其他事
>
> 异步非阻塞：
>
> >客户端发出请求，然后退出去做其他的事情，等待OS的通知
> >
> >直接去做别的，直至水壶发出响声

## JAVA集合

### 1.`List`、`Set`、`Map`

> List和Set都是继承自Collection类
>
> 不同的是
>
> > List可以添加重复的元素，允许插入多个null对象，且是一个有序的集合，输入的顺序就是输出的顺序，所以可以按照顺序进行访问。
> >
> > Set不能添加重复的元素，最多只允许插入一个null对象，且是一个无序容器，所以不能顺序访问其中的元素。但是TreeSet是依靠Comparator或Comparable维护了一个排序顺序。
>
> Map
>
> > 1. 实际上是一个接口，其中包含若干个Entry（entri:，实际上是一个内部的接口）。
> > 2. 每个Entry包含两个对象，也就是一个键一个值。
> > 3. Map中的键不可以重复，值可以重复
> > 4. 键最多只能存在一个null值，但是值可以存在多个null值
>
> 优点
>
> > List
> >
> > >适合经常使用下标进行访问的情况
> > >
> > >如果经常添加或删除元素，则使用LinkedList
> >
> > Set
> >
> > >适合检验唯一性，因为其中不能出现重复的值
> >
> > Map
> >
> > >适合以键值对的形式进行存储的场景

### 2.`ArrayList`和`LinkedList`、`ArrayList`和`vector`的区别以及它们的扩容机制

> ArrayList和LinkedList
>
> > 相同点：都不能保证线程安全
> >
> > 区别：
> >
> > 1. 底层实现方式不同
> >
> >    ArrayList使用数组存储
> >
> >    LinkedList使用双向链表进行存储
> >
> >    正是因为底层的实现方式不同，导致了两种列表在查询、插入和删除时存在的差异
> >
> > 2. 查询操作
> >
> >    因为ArrayList使用数组存储，所以可以根据下标进行访问，随机快速访问
> >
> >    LinkedList使用双向链表进行存储，所以想要访问只能一个遍历，不支持随机快速访问
> >
> > 3. 插入或删除
> >
> >    ArrayList使用数组存储，所以插入和删除操作要进行数组的移位操作，比较麻烦
> >
> >    LinkedList使用双向链表进行存储，所以插入和删除操作需要改变指针的指向即可，比较方便快捷
> >
> > 4. 内存占用
> >
> >    ArrayList使用数组存储，所以只能使用连续的空间进行存储，且为了应对数组长度的增加，要在尾部预留空间，存在内存浪费
> >
> >    LinkedList使用双向链表进行存储，所以可以使用离散的空间进行存储，且不存在内存浪费的情况
>
> ArrayList和vector
>
> > 相同点：都是使用数组作为底层实现
> >
> > 区别：
> >
> > 1. ArrayList不能保证线程安全，但是Vector其中的方法使用synchronized关键字进行了修饰，所以可以保证线程安全
> >
> > 2. 扩容机制不同
> >
> >    ArrayList的构造方式存在三种
> >
> >    1. 无参构造，初始化长度为0
> >    2. 传入初始化对象的有参构造，初始化长度为对象的长度
> >    3. 传入Collection的有参构造，首先将集合转换为数组，初始化长度为数组的长度，此时数组是满的
> >
> >    进行扩容时，ArrayList的扩容机制是扩充到当前容量的1.5倍
> >
> >    Vector的扩容机制是扩充到当前容量的2倍

### 3.`HashMap`和`HashTable`的区别

> |     区别     |                           HashMap                           |                          HashTable                           |
> | :----------: | :---------------------------------------------------------: | :----------------------------------------------------------: |
> |   线程安全   |                           不安全                            |            安全（方法使用synchronized关键字修饰）            |
> |     效率     |                          较高一些                           |                           较低一些                           |
> |    键和值    |             键最多只能存在一个null，值没有限制              | 不能存在null的值，会抛出NullPointerException（编译可以通过，但是运行会抛出异常） |
> |     父类     |                         AbstractMap                         |                          Dictionary                          |
> | contains方法 |             只有containsKey和containsValue方法              | 包含contains、containsKey、containsValue三种方法，contains和containsValue功能相同 |
> | 遍历方式不同 |                       实现了Iterator                        |                 实现了Iterator和Enumeration                  |
> |   hashcode   |   重新计算hashcode，新的hashcode=hashcode&（数组长度-1）    |                    直接使用key的hashcode                     |
> |   底层实现   |                     数组+链表（红黑树）                     |                          数组+链表                           |
> |  初始化容量  |               大小为16，阈值为12，比例为0.75                |                     大小为11，比例为0.75                     |
> | 传参数的大小 | 保证是2的幂次方（主要是为了计算hashcode是充分利用整个区间） |                      直接就是参数的大小                      |
> |   扩容方式   |                            2×old                            |                           2×old+1                            |
>
> |                  相同点                  |
> | :--------------------------------------: |
> | 都实现了Map、Cloneable、Serializable接口 |
> |                                          |
> |                                          |
>
> 



```java
// 实际上已经将tab[i = n - 1 & hash])赋值给了p

// 首先检测当前位置是否为空，为空直接插入,放在数组中
if ((p = tab[i = n - 1 & hash]) == null) {
    tab[i] = this.newNode(hash, key, value, (HashMap.Node)null);
} else {// 如当前位置不为空
    Object e;
    Object k;
    // 首先判断当前位置存储的键值是否和当前传入的键值相同，相同的话则直接覆盖原有的value
    if (((HashMap.Node)p).hash == hash && ((k = ((HashMap.Node)p).key) == key || key != null && key.equals(k))) {
        e = p;
    } else if (p instanceof HashMap.TreeNode) {
        // 若当前位置的节点是一个红黑树的节点，则调用红黑树的putTreeVal方法
        e = ((HashMap.TreeNode)p).putTreeVal(this, tab, hash, key, value);
    } else {
        // 否则，将插入的节点存到链表中，插入的过程中统计产生哈希冲突的次数，以便实现链表和红黑树的相互转换
        int binCount = 0;

        while(true) {
            // 插入到链表尾部
            if ((e = ((HashMap.Node)p).next) == null) {
                ((HashMap.Node)p).next = this.newNode(hash, key, value, (HashMap.Node)null);
                // 插入完成后，若哈希冲突总次数超过阈值，则将链表转为红黑树
                if (binCount >= 7) {
                    this.treeifyBin(tab, hash);
                }
                break;
            }
		// 若在链表中存在键相同的，则不用再存了
            if (((HashMap.Node)e).hash == hash && ((k = ((HashMap.Node)e).key) == key || key != null && key.equals(k))) {
                break;
            }

            p = e;
            // 统计哈希冲突的次数
            ++binCount;
        }
    }
// 若e不为null，表示一定是当前位置和传入的键相同，则覆盖原有的value
    if (e != null) {
        V oldValue = ((HashMap.Node)e).value;
        if (!onlyIfAbsent || oldValue == null) {
            ((HashMap.Node)e).value = value;
        }

        this.afterNodeAccess((HashMap.Node)e);
        return oldValue;
    }
}
```

```java
for(HashMap.TreeNode e = this; e != null; e = next) {
    next = (HashMap.TreeNode)e.next;
    e.next = null;
    // 如果当前key是数组的最后一个，则loHead=e，否则loTail.next=e
    if ((e.hash & bit) == 0) {
        if ((e.prev = loTail) == null) {
            loHead = e;
        } else {
            loTail.next = e;
        }

        loTail = e;
        ++lc;
    } else {
        if ((e.prev = hiTail) == null) {
            hiHead = e;
        } else {
            hiTail.next = e;
        }

        hiTail = e;
        ++hc;
    }
}

if (loHead != null) {
    if (lc <= 6) {
        tab[index] = loHead.untreeify(map);
    } else {
        tab[index] = loHead;
        if (hiHead != null) {
            loHead.treeify(tab);
        }
    }
}

if (hiHead != null) {
    if (hc <= 6) {
        tab[index + bit] = hiHead.untreeify(map);
    } else {
        tab[index + bit] = hiHead;
        if (loHead != null) {
            hiHead.treeify(tab);
        }
    }
}
```

### 4.`HashMap`相关知识

HashMap

> 实现了Map、Cloneable、Serializable接口，所以可以被克隆，进行序列化操作。
>
> 其默认长度被设置为16
>
> 底层实现是（`HashMap.Node<k,v>[] table`）：数组+链表+红黑树
>
> > 使用数组的目的是为了更快的对key进行查询操作，使用链表是为了解决哈希冲突的问题。
> >
> > 整个的存储过程如下：==put方法==
> >
> > > 1. 使用put方法，会调用putVal方法，其中会传递一个使用hash函数计算得到hashcode作为参数
> > > 2. 然后进行判断
> > >
> > >    1. 若当前位置的对象是null的话，则直接创建新的节点，也就是直接插入
> > >    2. 否则
> > >       1. 若当前的哈希值存有数据，且键相等，则将原有的value覆盖
> > >       2. 否则检测当前点是否是一个红黑树的节点，是的话则调用红黑树的putTreeVal方法
> > >       3. 否则插入到链表尾部，在插入的过程中统计哈希冲突的个数，以便转换为红黑树
> > > 3. 然后modCount++(在线程不安全的Iterator迭代器的子类中都存在，只要传入的modCount和迭代器中的值不一致，则抛出异常)
> > > 4. 检查当前HashMap的存储长度是否达到阈值，到达阈值的话则扩容
> >
> > ==扩容机制==
> >
> > > 1. 若当前的长度不为0
> > >    1. 若当前的长度大于等于`Integer.MAX_VALUE/2+1`的话，则新的阈值直接是`Integer.MAX_VALUE`，返回当前的数组
> > >    2. 否则的话，新的阈值是当前阈值的一倍
> > > 2. 否则
> > >    1. 当前阈值大于0的话，则新的容量等于当前阈值
> > >    2. 否则新的阈值和容量分别是12和16
> > > 3. 然后创建新的数组，并将当前数组的数据转移到新数组内
> > >
> > > 默认情况下，`阈值=容量*0.75`，这个比例是可以修改的。调用`HashMap(初始容量，比例)`方法
> > >
> > > ==需要注意的是==
> > >
> > > 当判断当前是红黑树时，会使用split方法对红黑树进行划分
> > >
> > > > 1. 根据当前数组的长度将红黑树的节点分为两部分
> > > > 2. 分别统计两部分的元素个数
> > > > 3. 若当前部分的元素数量小于等于6，则调用untreeify方法，将红黑树转换为链表，否则转换为红黑树
> >
> > ==链表转换为红黑树==
> >
> > >当哈希冲突个数（链表长度）大于等于7个时，调用treeifyBin方法
> > >
> > >1. 若当前数组的长度大于等于64
> > >   1. 获取链表的头节点
> > >   2. 然后搭建红黑树（红黑树是一种平衡二叉查找树，但并不是严格意义上的平衡二叉树，因为其左右子树的高度差可能会大于1。使用红黑树的原因是查询速度比较快，且对其平衡的代价比较低）
> > >2. 否则调用resize方法（主要目的是减少哈希冲突的数量——重新计算hashcode，然后将原本聚集在一起的元素分散开（产生大量哈希冲突的地方））
> >
> > ==红黑树转换为链表==
> >
> > >主要出现在remove节点时和resize时，判断哈希冲突数量是否大于等于7，使用`untreeify`方法将红黑树转换为链表。

### 5.`HashSet`相关知识

> 基于HashMap实现，HashMap是transient关键字修饰，表示该对象的生命周期只存在内存上，而不会被持久化到磁盘。
>
> 默认将所有的value都设置为一个空的Object对象，然后一切的操作都是使用HashMap实现。
>
> 关于添加重复元素，
>
> > add方法直接调用HashMap的put方法，间接调用putVal方法。
> >
> > 因为putVal方法中是当hashcode相同且key时，值覆盖值，所以也就不会添加新的元素了。

#### `5.2HashSet`、`LinkedHashSet`、`TreeSet`

> LinkedHashSet继承了HashSet，所以基本的都一致，但因为是使用链表实现的，所以可以根据输入的顺序进行遍历。
>
> TreeSet继承了AbstractSet，是基于TreeMap实现的，所以不能添加null值，否则运行时会抛出异常NullPointerException
>
> 相似点
>
> |  相同点  |
> | :--------------------: |
> |    都是线程不安全的    |
> | 都可以保证元素的唯一性 |
>
> 区别
>
> |        |   HashSet    |  LinkedHashSet   |    TreeSet     |
> | :----: | :----------: | :--------------: | :------------: |
> |  父类  | AbstractSet  |     HashSet      |  AbstractSet   |
> | null值 | 最多存储一个 |   最多存储一个   |  不能存储null  |
> |  顺序  | 不能保证顺序 | 可以保证插入顺序 | 可以自定义排序 |
> |  效率  | 增、查速度快 |  增、删速度较快  |                |
>
> 

### 6.`ConcurrentHashMap`和`HashTable`的区别

> 相同点
>
> |                           相同点                           |
> | :--------------------------------------------------------: |
> | 都不能存储null值，只要存储就会抛出NullPointerException异常 |
>
> > HashTable抛出异常的原因是：值不能为null，因为源码是这样设置的，原因是：
>
> > ConcurrentHashMap抛出异常的原因还是因为要保持线程安全的缘故：
> >
> > > 如果ConcurrentHashMap调用get(key)方法获得一个value为null时，此时的null有两种含义：1. value为null，2. 该key是不存在的，所以返回值为null
> > >
> > > 而ConcurrentHashMap无法进行判断，但是HashMap可以通过containsKey来解决这个二义性的问题，但是ConcurrentHashMap为了确保线程安全，使用了volatile关键字修饰了Node元素，所以在多线程情况下所有对Node的修改都是全局可见的。那么需要考虑这种情况：当A调用get(key)方法时，同样调用containsKey来解决二义性问题的话，如果B在A调用containsKey方法之前就调用put(key)方法的话，那么此时containsKey的结果就是true，与预期是不相符的。
>
> 区别
>
> |                        |                      ConcurrentHashMap                       |              HashTable               |
> | :--------------------: | :----------------------------------------------------------: | :----------------------------------: |
> |      底层结构不同      |                     Node数组+链表/红黑树                     |            Entry数组+链表            |
> | 实现线程安全的方式不同 | 将数据分为多份，每份分别加锁<br>1.8之前使用segment实现<br>1.8开始使用synchronized+CAS原子操作实现 | 使用synchronized实现，但是只加一个锁 |
>
> 
>
> ConcurrentHashMap
>
> > 1.8之前
> >
> > > 使用segment数组+HashEntry链表结构，segment是一种可重入锁（`ReentrantLock`）的数据结构
> > >
> > > 因为将数据分为了多份，且每一份都有自己的锁，所以与HashTable相比，提高了并发性能。
> > >
> > 
> >1.8开始
> > 
> >> 使用Node数组+链表/红黑树的结构（提升了访问效率，由O(n)-->O(log n)）。使用CAS+synchronized实现线程安全性。
> > >
> > > 弃用segment+ReentrantLock使用CAS+synchronize的原因（当指向的位置为null时，使用CAS操作添加新的value）
> > >
> > > > 1. 可重入锁（ReentrantLock）需要每个节点继承AQS来获取同步支持，会增加内存开销；而1.8开始只需要对每个数组的头节点进行同步
> > > > 2. synchronized是JVM内部支持的，JVM可以在运行时做出相应的优化措施，使得synchronized可以在JDK版本升级后不做任何修改便可以得到提升

### 7.序列化和反序列化

> 序列化和反序列实际上就是java对象和字节码之间的转换。
>
> 序列化
>
> > 就是将java对象转换为字节码，以便在网络上进行传输或保存到本地文件中，以便利用反序列化机制重建对象。
> >
> > 具体实现：
> >
> > > 1. 让需要进行序列化的对象实现Serializable接口或Externalizable接口（需要重写writeObject接口）
> > > 2. 然后调用序列化流对象OutputStream类的writeObject方法将传入的obj对象序列化
>
> 反序列化
>
> > 反序列化时，必须提供.class文件。
> >
> > 为了让不同版本的.class文件互相兼容，在序列化时添加一个version值，只要两个.class文件的version值相同，就可以反序列化

## JAVA多线程

### 1.进程和线程

> 进程
>
> > 进程就是程序的一次执行过程，是系统运行程序的基本单位，是动态的。
> >
> > 一个进行创建、调用、销毁的过程就是一个程序运行的过程。
>
> 线程
>
> > 线程是比进程更加小的单位，一个进程可以由若干个线程组成。
> >
> > 同一进程下的多个线程共享该进程的堆（存储新创建的对象）和方法区（存储已被加载的类信息，如常量、静态变量等），每个线程独自拥有各自的程序计数器、虚拟机栈、本地方法栈。

### 2.程序计数器为什么是私有的

> 程序计数器的作用是记录当前线程运行的位置，以便再次轮询到时可以接着上一次继续执行。

### 3.虚拟机栈和本地方法栈为什么是私有的

> 虚拟机栈存储的是运行过程中产生的局部变量表、操作数等数据，一个java方法从被调用到执行完毕的过程，就是虚拟机栈不断入栈出栈的过程。
>
> 本地方法栈存储的是虚拟机使用的本地native方法

### 4.并发和并行的区别

> 并发是指在一段时间内，多个任务都在执行，但不一定是同时执行。
>
> 并行是指在单位时间内多个任务同时执行。

### 5.使用多线程的原因

> 1. 线程是程序运行过程中的最小单位，线程的创建、切换等操作一定比进行要小，且多核处理器的出现同样为多线程的实现提供了条件，减少了上下文切换的开销
> 2. 使用单核处理器时，使用多线程的主要目的是提高CPU和IO的效率，因为此时CPU和IO操作同一时间只能运行一个
> 3. 使用多核处理器时，使用多线程的主要目的是提高CPU的效率

#### 使用多线程存在的问题

> 1. 内存泄露
>
>    简单来说就是不再使用的java对象所占的内存不会被回收，只占地方不干活
>
> 2. 上下文切换
>
> 3. 线程死锁

### 6.上下文切换操作

> 上下文切换就是指当前线程保存状态，将CPU让给其他线程，到再次轮到使用CPU的过程。
>
> 若该过程发生的比较频繁，则会操作大量的额外开销，影响效率

### 7.线程死锁

> 线程死锁就是多个线程互相持有对方需要的资源，相互阻塞。
>
> 产生死锁的条件（需要同时满足四个条件才会形成死锁）：
>
> > 1. 互斥条件
> >
> >    一个资源在同一时间只能一个线程持有
> >
> > 2. 请求和保持
> >
> >    当线程对其他资源发出请求并被阻塞时，不会释放已持有的资源
> >
> > 3. 不可强制剥夺
> >
> >    线程持有的资源除了它使用完主动释放，不可以被强行剥夺
> >
> > 4. 循环等待
> >
> >    若干线程形成一种头尾相连的循环等待的关系

### 8.避免死锁的策略

> 1. 互斥条件是不可以被破坏的，会导致数据紊乱
>
> 2. 破坏请求和保持条件
>
>    在线程执行之前，先将所有需要的资源全部请求并占有
>
> 3. 破坏不可强制剥夺条件
>
>    若一个线程请求其他资源时被阻塞，则将其持有的其它资源全部释放
>
> 4. 破坏循环等待条件
>
>    按照某种顺序依次请求资源，然后反向释放资源

### 9.Thread.sleep()和Thread.wait()的区别

> 相同点：
>
> 1. 都可以使线程停止
>
> 区别：
>
> |        |      sleep       |                             wait                             |
> | :----: | :--------------: | :----------------------------------------------------------: |
> | 释放锁 |   并没有释放锁   |                           释放了锁                           |
> |  用途  |   用于短暂暂停   |                    用于线程间的通信、交互                    |
> |  唤醒  | 线程可以自动唤醒 | 一旦被调用，只能使用其他线程调用notify方法或notifyAll方法，来唤醒当前线程 |

### 10.为什么调用start()方法会自动调用run()方法，而无法直接调用run()方法

> 因为在多线程的情况下，调用start方法会启动线程并进入就绪状态，当获得可以启动的条件后就可以重新自动启动。
>
> 如果直接调用run方法的话，那么编译器会认为调用的是本地方法，所以不能启动线程。

### 11.对`synchronized`关键字的理解

> 1. synchronized关键字可以用来修饰方法或代码块，可以保证被synchronized关键字修饰的方法或代码块，在同一时间最多只会执行一个，不可以同时执行多个。
>
> 2. 在JDK早期版本，synchronized属于重量级锁，效率比较低。
>
>    > 主要原因是因为Monitor（监视器锁）是依赖操作系统底层的MutexLock实现的，java的线程需要映射到操作系统的线程上，因此线程的挂起和唤醒都是需要操作系统来实现的，而操作系统实现线程的切换时，需要实现内核态和用户态之间的相互转换，所以比较耗时。
>
> 3. JDK6之后，JVM对synchronized进行了优化，增加了偏向锁、轻量级锁、自旋锁等，来减少线程上下文切换导致的开销。
>
>    > 1. 自旋锁
>    >
>    >    自旋锁就是：当持有锁的线程在短时间内释放锁住的资源的话，那么那些等待竞争锁的线程就无需进行内核态和用户态的转换而进入阻塞状态，只需要进行一段时间的自旋，等待持有锁的线程释放资源后即可获取，从而减少内核态和用户态切换所造成的开销。
>    >
>    >    > 优点：
>    >    >
>    >    > ​		可以尽可能的减少线程阻塞情况的发生，比较适合竞争不激烈、占用锁时间非常短的情况。
>    >    >
>    >    > 缺点：
>    >    >
>    >    > ​		如果遇到竞争激烈且占用锁时间非常长的情况，就会出现大量线程都在自旋等待一个资源的释放，消耗大量cpu资源进行自旋操作，浪费cpu资源。
>    >
>    >    适应性自旋：
>    >
>    >    ​	若此轮自旋并没有获得锁，下一轮自旋的次数会增多（也就是增加等待时间），若此轮自旋获得了锁，则下一轮自旋次数会减少
>    >
>    > 2. 偏向锁
>    >
>    >    简单来讲，就是锁偏向某个线程，当某个线程获取锁之后，其再次想获取锁时，不需要获得锁，直接就可以执行同步代码块（忽略前面的synchronized关键字）
>    >
>    >    > 优点：
>    >    >
>    >    > ​		比较适合竞争较少的情况，因为只需要在切换线程时才需要执行CAS操作
>    >    >
>    >    > 缺点：
>    >    >
>    >    > ​		不适合在多线程激烈竞争的情况下执行，因为需要频繁的切换线程，执行大量的CAS操作
>    >
>    > 3. 轻量级锁
>    >
>    >    不是用来替代重量级锁的，而是为了在没有多线程竞争的情况下，来减少性能消耗。当遇到多线程竞争锁时，会自动膨胀为重量级锁。
>    >
>    >    > 适用于线程交替执行的状态，也就是没有多线程竞争的状态
>    >
>    > 4. 重量级锁
>    >
>    >    当有其他线程持有锁时，当前线程进入阻塞状态
>    >
>    > 5. 锁粗化
>    >
>    >    将多次连接在一起的加锁、解锁操作合并为一次；
>    >
>    >    将多个连续的锁合并为一个更大范围的锁
>    >
>    > 6. 锁消除
>    >
>    >    也就是删除不必要的加锁操作
>    >
>    >    根据代码逃逸原则：如果判断一段代码中，堆上的数据不会逃逸出当前线程，则认定当前代码是线程安全的，则无需加锁。

### 12.`synchronized`关键字的使用

> 1. 同时访问synchronized修饰的静态和非静态方法，可以保证线程安全吗？
>
>    不能保证。因为synchronized修饰的静态方法使用的是类锁 xx.class，而synchronized修饰的非静态方法使用的是this
>
> 2. 同时访问synchronized修饰的方法和非同步方法，可以保证线程安全吗？
>
>    不可以保证线程同步，因为synchronized只能保证所有使用synchronized修饰的方法或代码块的线程安全。
>
> 3. 若两个线程同时访问synchronized修饰的方法，可以保证线程安全吗？
>
>    不能保证线程安全。因为每个对象都具有自己的锁，并不是共享一把锁。（如果是类锁的话，所有对象共享一把锁）。
>
> 4. 若synchronized抛出异常，会导致死锁吗？
>
>    不会死锁，JVM会自动释放锁。因为synchronized是可重入锁之一，可以自动释放锁。而另一个可重入锁ReentrantLock必须要手动释放锁。
>
> 5. synchronized的锁对象可以为空吗？
>
>    不可以为null，否则会抛出NullPointerException的异常，这是java语言规范所规定的
>
> 6. synchronized的继承性问题？
>
>    如果子类方法重写了父类的synchronized修饰的同步方法，
>
>    1. 若子类方法没有使用synchronized修饰
>
>       因为synchronized不具备继承性，所以子类方法是线程不安全的
>
>    2. 子类方法使用synchronized修饰
>
>       两个锁对象实际上是同一把锁，且子类对象作为锁，这也证明了synchronized是可重入锁，因此可以避免死锁情况的出现。
>
> 7. synchronized的同步范围
>
>    synchronized的同步范围是越小越好，越小代表锁粒度越小，从而对效率也不会产生太大的影响。

### 13.双重校验锁实现对象单例

>
>
>```java
>class SingleInstance{
>    /**
>    使用volatile关键字的原因是为了禁止重排序
>    因为如果A执行2时，实际上会实现以下步骤
>    1. jvm为对象分配空间
>    2. 初始化对象
>    3. 将instance引用指向地址
>    
>    但是，若此时B指向了1，A则有可能会得到一个为null的返回值，主要原因是因为：
>   		处理器阶段，会出现一些系统优化的重排序问题
>   	为了解决这个问题，使用volatile关键字，将该变量标记为共享的，因此该变量不会参与到重排序中，所以每次读取到的都是最新写入的值。
>    */
>    private volatile static SingleInstance instance = null;
>
>    private SingleInstance(){}
>    public static SingleInstance getInstance(){
>        if (instance==null) // 1
>        {
>            synchronized (SingleInstance.class)
>            {
>                if (instance == null)
>                {
>                    instance = new SingleInstance();// 2
>                }
>            }
>        }
>        return instance;
>    }
>}
>```
>
>

### 14.`synchronized`关键字的底层实现原理

>synchronized的底层实现，实际上是对监视器锁Monitor的获取。
>
>1. 使用synchronized同步代码块
>
>   实际上是使用`monitorenter`和`monitorexit`来标识同步块的入口位置和出口位置
>
>   `monitorenter`获取monitor
>
>   `monitorexit`释放monitor
>
>   实现步骤：
>
>   1. 首先执行`monitorenter`，尝试获取对象的锁，也就是monitor的持有权，如果锁的计数器为0表示可以被获取，获取后将锁的计数器置为1
>   2. 执行`monitorexit`时，将锁的计数器置为0，表示锁已经被释放了
>
>2. 使用synchronized同步方法
>
>   使用`ACC_SYNCHRONIZED`标识来指明当前方法是一个同步方法，然后由JVM执行相应的同步调用

### 15.`synchronized`关键字和volatile关键字的区别

|                        |                    volatile                    |            synchronized            |
| :--------------------: | :--------------------------------------------: | :--------------------------------: |
|          效率          |      是线程安全的轻量级实现，所以效率较高      |      存在多个状态，效率不一定      |
|        使用范围        |                只能用来修饰变量                |        用来修饰代码块和方法        |
| java内存模型的三大特性 | 可以保证数据的可见性，但是不能保证数据的原子性 |    可以保证数据的可见性和原子性    |
|       解决的问题       |         解决变量在多进程情况下的可见性         | 解决多线程情况下资源访问的同步问题 |

### 16.`Java`内存模型的三个方面：原子性、可见性、有序性

> 1. 原子性
>
>    简单来说就是一系列的操作，要么全部执行成功，要么全部不执行（或回退到原本的状态）。
>
>    在java中，只存在于静态变量、实例变量、数组原始的读写操作中，不存在于局部变量中；
>
>    对于基本数据类型而言，double和float不一定是原子性的。因为double和float都是64位的，在32位系统中，需要分为两个32位进行存储，所以不是原子的。而在64位系统中，是原子的。
>
> 2. 可见性
>
>    一个线程对变量做出修改后，其他的线程可以立即感知到其变化，。
>
>    可以通过volatile、synchronized、lock、final实现。
>
>    1. volatile
>
>       将使用volatile修饰的变量修改后立即同步到内存中，每次使用volatile修饰的变量都到内存中读取最新值，从而保证了可见性
>
>    2. synchronized
>
>       在同步代码块/方法中使用共享变量时，先变量的值从主内存保存到私有内存中，然后修改后立即保存到主内存中，从而实现可见性（涉及到ThreadLocal的相关问题）
>
>    3. lock
>
>       一般是使用ReentrantLock实现，具体和synchronized类似
>
>    4. final
>
>       使用final修饰的变量一旦被初始化，那么所有的线程都会收到消息。

### 17.`ThreadLocal`的原理、内存泄漏问题

> 1. `ThreadLocal`就是为每一个线程绑定一个自己的值，从而拥有自己的一块私有空间存储私有数据。
>
> 2. 如果创建了一个`ThreadLocal`的变量，每一个访问该变量的线程都会有一个当前变量的本地副本，用于存储该变量的值，同时可以使用get和set方法，来获取该变量的值或将本地副本的值覆盖该变量的值。
>
> 3. 底层实现
>
>    1. Thread类中存在两个变量`threadLocals`和`inheritedThreadLocals`，默认为null，它们都是`ThreadLocalMap`
>    2. `ThreadLocal`实际上是对`ThreadLocalMap`的封装
>    3. `ThreadLocal`内部维护`ThreadLocalMap`，key存储的是当前的`ThreadLocal`对象，而value存储的是值
>
> 4. 作用
>
>    1. 在进行对象跨层传递时，可以使用`ThreadLocal`避免多次传递，打破层次间的约束
>    2. 在线程间起到数据隔离的作用
>    3. 进行事务操作，用于存储线程的事务信息
>    4. 数据库连接，session会话管理
>
> 5. 内存泄露问题
>
>    因为`ThreadLocal`是弱引用，所以当key为null时，表示当前key不再会被引用，所以会被GC自动清除。但此时会遇到一个问题
>
>    > 如果`ThreadLocal`为null要被清除了，而`ThreadLocalMap`的生存周期与Thread相同，所以不会被清除，此时产生一个现象：`ThreadLocalMap`的key被清除了，但是value还在，也就产生了内存泄露的问题
>
>    解决办法：
>
>    ​		在使用完`ThreadLocal`后，调用remove方法事先清除value，从而避免内存泄露问题的出现。

### 18.强引用、软引用、弱引用、虚引用

> 1. 强引用
>
>    主要使用了强引用，GC便不会主动回收该对象的内存空间，即便因为内存空间不足而报错也不会回收。
>
>    当不使用强引用的对象时，需要显式的将其置为null或超过其生命周期后，GC才会回收其内存空间。
>
>    强引用的例子：`String str = "abc"`
>
> 2. 软引用
>
>    只要使用了软引用，当内存空间充足时不会回收其对象，当内存空间不足时，GC会自动回收其内存空间，可以用来实现内存敏感的高速缓存。
>
>    软引用的例子：`SoftReference<String> str = new SoftReference<>("abc")`
>
> 3. 弱引用
>
>    生命周期比软引用更短，无论内存空间释放充足，只要GC扫描到了弱引用的对象，就会回收其内存空间
>
>    弱引用的例子：`WeakReference<String> str = new WeakReference<>("abc")`
>
> 4. 虚引用
>
>    虚引用和没有引用没有什么区别，生命周期极短，主要用来根据GC的回收活动

### 19.线程池操作

使用池化技术的主要目的是减少频繁创建和销毁而造成的开销。

#### 19.1线程池的好处

>1. 减少开销
>
>2. 提高响应速度
>
>   因为可以使用早已创建好的线程，不用频繁的进行创建和销毁，所以可以减少这部分开销，且提高响应速度
>
>3. 方便进行管理和优化
>
>   因为线程池中都是已经创建好的线程，方便对线程进行分配、管理、优化等操作。

#### 19.2线程池实现`Runnable`和`Callable`的区别

> 1. Runnable是java1.0就存在的，所以不用担心版本的问题，但是它不会返回指向结果，且不能抛出异常，run的异常只能在内部进行处理
> 2. Callable可以返回结果，并可以在内部进行解决，也可以向上抛出异常

#### 19.3线程池`execute()`和`submit()`方法的区别

> 1. execute()方法可以用于提交不需要返回值的方法，因为没有返回值，所以也不知道该方法是否被线程池的线程执行成功
>
> 2. submit()方法可以用于提交一些需要返回值的方法，会返回一个future类型的结果，可以根据future类型的对象来判断当前方法是否执行成功，并且可以使用future类型对象的get方法来获取返回值。
>
>    需要注意的一点是，如果不调用get方法等，那么会直接结束当前程序，而后台运行提交的任务。如果使用get方法获取返回值的话，那么会阻塞当前程序，直至所有的任务执行完成。

#### 19.4线程池的创建

> 创建的方式主要有两种：
>
> new ThreadPoolExecutor()和new ThreadPoolExecutor(参数列表)
>
> 线程池主要有以下几种类型：
>
> 1. FixedThreadPool：创建一个线程数量固定的线程池，如果当前没有空闲的线程，则加入到等待队列中
> 2. SingleThreadPool：创建一个只有一个线程的线程池，如果没有空闲的线程，则加入到等待队列中
> 3. CachedThreadPool：创建一个线程数量不固定的线程池，若没有空闲的线程，且线程数量没有超过最大值，则创建一个新的线程来处理当前的任务，当存在大量的空闲线程，会逐渐销毁后来创建的额外的线程。

#### 19.5`Executors`创建线程池的问题

>1. `FixedThreadPool`和`SingleThreadPool`的等待队列的最大容纳数量为`Integer.MAX_VALUE`，所以当大量线程位于等待队列中时，会出现`OutOfMemory`的异常
>2. `CachedThreadPool`的最大线程数量也是`Integer.MAX_VALUE`，当创建了大量线程，同样会出现`OutOfMemory`的异常。

#### 19.6线程池原理分析

>1. 首先判断当前线程数量是否达到corePoolSize，没有达到的话，则创建一个新的线程来执行任务；
>2. 此时检查当前线程池的状态，若当前线程池的状态为RUNNING，且等待队列可以加入任务，此时将任务添加到等待队列中；
>3. 若等待队列已满，且线程数小于maxPoolSize的话，则创建新的线程执行任务；否则执行拒绝策略；

### 20.`Atomic`原子类

>就是指具有原子特征或原子操作的类.
>
>在多线程情况下，一个操作一旦执行，就不会被其他线程干扰。
>
>主要包括：
>
>1. `AtomicInteger`
>
>   整型原子类
>
>2. `AtomicLong`
>
>   长整型原子类
>
>3. `AtomicBoolean`
>
>   布尔原子类
>
>4. `AtomicIntegerArray`
>
>   整型数组原子类
>
>5. `AtomicLongArray`
>
>   长整型数组原子类
>
>6. `AtomicReferenceArray`
>
>   引用类型数组原子类
>
>7. `AtomicReference`
>
>   引用类型原子类
>
>8. `AtomicStampedReference`
>
>   带有版本号的引用类型原子类
>
>   可以解决原子更新数据和更新数据版本号的问题，并可以解决CAS操作中出现的ABA的问题。
>
>   > CAS的底层实现：
>   >
>   > ​	实际上是unsafe类提供的，是硬件级别的原子操作。
>   >
>   > ABA问题：
>   >
>   > ​	假设小明的账户原本有100元，
>   >
>   > 1. 小明取了50元，所以此时账户余额应该是50，但是修改操作提交了多次，分别是a和b操作；
>   > 2. 若此时a操作执行完成（A=100元，B=50元，对应的上，所以小明的余额为50元），b操作（A=100元，B=50元）因为某种原因被阻塞了，而小明的妈妈给小明打了50元，该操作c执行成功，此时，小明的账户余额为100元
>   > 3. 此时b操作开始执行，因为A和内存位置V内存的值对的上，所以进行了修改，最终小明的账户余额是50元，是不合理的、是有问题的。
>
>   可以携带版本号解决这个问题，当执行操作abc时分别对应版本号112，当执行完c后，版本号改为了2，当b执行时，虽然内存位置的值和A对应的上，但是因为版本号的不同，也不能执行，所以解决了ABA的问题。
>
>9. `AtomicMarkableReference`
>
>   带有标记位的引用类型原子类

### 21.`AQS(Abstract Queued Synchronizer)`抽象队列同步器

#### 21.1`AQS`的原理

>AQS抽象队列同步器
>
>是多种同步器实现的基础，如ReentrantLock、CountDownLatch等，可以继承AQS来自定义同步器。
>
>实现原理：
>
>1. 如果请求的共享资源是空闲的，则将请求线程设置为工作线程，且将该资源的状态设置为锁定状态；
>2. 若请求的资源是被占用的，则需要一套线程阻塞等待、被唤醒后锁分配的机制。AQS中使用CLH队列锁来实现这一机制：当将请求资源的线程封装为CLH中的节点，然后进行自旋操作，等待资源的释放，若自旋时间达到某一阈值，则会被阻塞。
>
>CLH实际上是一个虚拟的双向队列，也就是并不存在的一个队列，只是线程直接存在一些前后的节点关系而已。
>
>当CLH队列的头节点释放同步状态时，会唤醒其后续节点，然后头节点被移除，后续节点被当作头节点。

#### 21.2`AQS`对资源的共享方式

> 主要有两种：
>
> 1. 独占式：同一时间只有一个线程可以使用，如ReentrantLock
>
>    主要可以分为两种：
>
>    1. 公平锁：按照顺序依次获得资源的锁
>    2. 非公平锁：释放锁之后，谁抢到谁用
>
> 2. 共享式：多个线程可以同时执行，如CountDownLatch、Semaphore等

#### 21.3`AQS`的底层模板

> 1. 继承AbstractQueuedSynchronizer类，并重写指定的方法即可。（主要是实现共享资源的获取和释放，其他的方法都已经被AQS实现了，可以直接调用）
> 2. 然后将AQS组合在自定义的同步组件中，并调用其模板方法，这些模板方法会自动调用自定义的重写方法。
>
> tryAcquire()、tryRelease()是独占方式
>
> tryAcquireShared()、tryReleaseShared()是共享方式
>
> 默认情况下，上述的方法都会抛出UnsupportedOperationException异常，因为这些方法必须是内部线程安全的，并且通常是简短且不重复的。

#### 21.4`AQS`组件

>1. Semaphore信号量：可以运行多个线程同时访问同一资源
>
>   synchronized和reentrantlock都是在同一时间只能运行一个线程访问资源
>
>   semaphore信号量可以运行多个线程同时访问资源
>
>   > 信号量主要是用来处理资源具有多个的问题。
>   >
>   > 其内部存在一个计数器，表示可用资源的数量
>   >
>   > 比如，具有多个打印机，当一个请求使用打印机时，将信号量减一；用完之后释放资源，信号量加一
>   >
>   > 当信号量大于0时，表示还有资源可以访问；若信号量为0时，线程被阻塞，直到信号量大于1时被唤醒。
>
>2. CountDownLatch倒计时器：运行若干个线程阻塞在同一个位置
>
>   常被用来控制线程等待，具体是：
>
>   > 给某个线程设置countdownlatch(N)，N表示等待N个线程执行完之后，该线程才可以执行；
>   >
>   > 若当前线程执行到了某个位置，则需要等待若干个线程完成才可以继续执行，在此期间执行的线程会调用countdownlatch的countdown方法，使计数器减一。
>
>   > 需要注意的是，countdownlatch可以用在任何位置，所以不一定只代表需要等待若干个线程执行完才可以执行，也可以表示线程内部的若干个步骤执行完才可以执行。
>
>   > 缺点：
>   >
>   > 1. countdownlatch是一次性的，一旦被使用，其中的N值便不能被改变，也不能重复使用
>
>3. CyclicBarrier循环栅栏
>
>   比CountDownLatch更加强大，当线程执行到某个屏障时就停止，只有当所有的线程都执行到该屏障时才会全部放行，这些线程才可以执行后续的操作。
>
>   > 与countdownlatch不同的是，cyclicbarrier是可以重复使用的

#### 22.`CountDownLatch`的使用

>在项目中，需要向客户返回多个文件的处理结果，使用多线程处理多个文件，然后使用countdownlatch来保证多线程产生的多个结果可以同时返回给客户。

### 23.`java`设计模式--23种

> 根据功能进行划分，可以分为三种：
>
> 1. 创建型设计模式
>
>    包含
>
>    1. 单例模式：一个类只有一个实例对象，该类提供了一个全局访问点供外部获得实例。
>    2. 原型方法：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例对象
>    3. 工厂方法：定义一个用于创建产品的接口，由子类决定生产什么产品
>    4. 抽象工厂：提供一个创建产品族的接口，其每个子类可以生产一系列的相关产品
>    5. 建造者模式：将一个复杂对象分解为多个相对简单的部分，然后根据不同的需求分别创建它们，最后构建成该复杂对象
>
> 2. 结构型设计模式
>
>    包含
>
>    1. 代理模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
>    2. 装饰器模式：动态的给对象增加一些职责，即增加其额外的功能。
>    3. 组合模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性
>    4. 桥接模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
>    5. 适配器模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
>    6. 外观模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
>    7. 享元模式：运用共享技术来有效地支持大量细粒度对象的复用。
>
> 3. 行为型设计模式
>
>    包含
>    
>    1. 模板方法：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
>    
>    2. 解释器：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。
>    
>    3. 策略模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
>    
>    4. 观察者模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
>    
>    5. 中介者模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
>    
>       等
>
> 根据作用对象进行划分，可以分为
>
> 1. 类模式：用于处理类与子类之间的关系，这些关系通过继承来实现，是静态的，在编译时就已经确定了的。
>
>    包含工厂方法、（类）适配器、模板方法、解释器
>
> 2. 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行过程中是可以动态变化的，更具动态性。
>
> 设计模式的七大基本原则：
>
> 1. 开闭原则
>
>    对扩展开放，对修改关闭。
>
>    当程序需要进行扩展时，不能修改原有代码，而是要实现热拔插的效果。
>
>    简单来说就是，活用接口和抽象类，来使得代码具有良好的扩展性，且易于维护和升级。
>
>    ==降低维护带来的风险==
>
> 2. 里氏替换原则
>
>    简单来说，就是子类可以扩展父类的功能，但不能改写父类的功能。
>
>    也就是说子类除了增加新的功能外，尽量不要重写父类的方法。
>
>    ==防止继承泛滥==
>
> 3. 依赖倒转原则
>
>    简单来说就是功能的实现要依赖抽象，而不是依赖于具体的情况，实际上是对客户与实现进行解耦
>
>    ==利于代码的升级和扩展==
>
> 4. 接口隔离原则
>
>    使用多个接口来完成任务，比只是用一个接口完成任务要好
>
>    ==将功能解耦，高内聚低耦合==
>
> 5. 迪米特原则（最少知道原则）
>
>    一个实体应该尽量少于其他的实体之间发生相互关系，使得系统的功能模块之间相对独立。
>
>    ==减少代码臃肿的情况==
>
> 6. 合成复用原则
>
>    尽量使用组合或聚合的方式实现功能，少使用继承操作
>
>    ==降低代码耦合==
>
> 7. 单一职责原则
>
>    一个类只做一件事，实现类要单一
>
>    ==便于理解，提高代码的可读性==

#### 23.1单例模式

> 就是一个类包含一个实例对象，并且该实例对象由该类自行创建，该类只提供一个访问该单例实例的全局访问点。
>
> 优点：
>
> 1. 因为只有一个实例对象，节省了内存开销
> 2. 可以避免对资源的多重占用
> 3. 因为提供了一个全局访问接口，所以可以优化资源的访问
>
> 缺点：
>
> 1. 单例模式一般没有接口，所以难以进行扩展。如果非要进行扩展，除非修改原本的代码，这样就违背了==开闭原则==；
> 2. 因为单例模式只包含一个单例实例，所以在进行测试时比较不友好，因为只有等待实例执行测试完当前部分才可以测试其他的部分，不能重复创建多个实例；
> 3. 单例模式的功能都写在一个类中，如果功能设置的不合理，那么很容易违背==单一职责原则==；
>
> 适用情况：
>
> 1. 存在大量实例频繁被创建、频繁被销毁的情况，如多线程的线程池、网络的连接池等
> 2. 需要频繁创建一些类的情况，使用单例模式可以减少内存开销，减少GC次数
> 3. 需要频繁访问数据或文件的情况
> 4. 某些类创建实例时占用资源较多，或实例化时间较长，且频繁使用的情况

#### 23.2原型模式

>简单来说，就是通过复制的方式克隆大量与当前实例类似的实例；无需直到创建的实现细节。
>
>优点：
>
>1. java的原型模式是基于二进制流的复制，所以从性能上讲，比new创建一个实例更快；
>2. 可以使用深拷贝来保存当前实例的所有信息，在需要时直接拿出来就可以完成实例的创建，还可以辅助实现撤销操作（将代码回退到某一版本）
>
>缺点：
>
>1. 因为是基于复制的克隆，所以需要为每个方法实现一个clone方法
>2. 但因为clone方法是类的内部方法，所以在对已有类进行修改时，违背了==开闭原则==
>3. 实现深拷贝功能，代码比较复杂，且一旦涉及到对象的嵌套引用，需要嵌套的每层的类都要实现深拷贝，所以要合理使用深拷贝和浅拷贝

#### 23.3工厂模式

>简单工厂模式（也称静态工厂模式）——不属于23中设计模式之一
>
>> 有一个具体的工厂类，可以生成多个不同的产品。
>>
>> 每增加一个产品，就要增加一个具体的产品类及其一个对应的具体工厂类，这违背了==开闭原则==。
>>
>> 缺点：
>>
>> 1. 工程类单一，负责所有产品的创建，职责过重，一旦异常整个系统都会受到影响，且整个工程类的代码过于臃肿，违背了高聚合原则；
>> 2. 使用简单工厂模式会增加代码中类的数量，增加了系统的复杂度和理解难度
>> 3. 系统扩展困难，一旦增加新的产品类必须要修改工厂逻辑，可能会造成逻辑过于复杂
>> 4. 简单工程类使用了static工厂方法，造成工厂角色完成形成基于继承的等级结构。
>
>因为简单工厂模式违背了开闭原则，所以提出了==工厂模式==
>
>> 就是对简单工厂模式进一步抽象化，使得可以在不修改原有代码的情况下引入新产品，满足了开闭原则
>>
>> 优点：
>>
>> 1. 用户只需直到具体的工厂名称就可以得到所需的产品，无需直到产品具体的创建过程
>> 2. 灵活性增加，新产品的添加只需要多些一个新的工厂类即可
>> 3. 典型的解耦框架。高层模块只需知道产品的抽象类，无需关心其他的实现类，满足迪米特原则、里氏替换原则、依赖倒置原则。
>>
>> 缺点：
>>
>> 1. 还是容易产生大量的类，增加代码的复杂度
>> 2. 增加了系统的抽象性和理解难度
>> 3. 抽象产品只能生成一种产品（工厂模式只考虑生产同等级的产品），此弊端可以使用抽象工厂解决

#### 23.4抽象工厂模式

>简单来说，工厂类是对一个类别的产品进行了抽象（如电视包含海尔电视、海信电视等），而抽象工厂类是对一个品牌的产品进行抽象（如海尔公司包含海尔电视、海尔洗衣机等）。
>
>抽象工厂模式的实现条件：
>
>1. 系统中存在多个产品族，每个具体工厂创建属于同一族，但不属于不同等级结构的产品
>2. 系统一次只能消费某一族产品，即同族的产品一起使用
>
>优点：
>
>1. 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必引入多个类来进行管理
>2. 当需要产品时，抽象工厂可以保证客户端始终只使用同一产品组下的产品
>3. 增加了程序的可扩展性，当增加一个新的产品族时，不需要修改源代码，满足开闭原则
>
>缺点：
>
>1. 当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改，增加了系统的抽象性和理解难度。

#### 23.5建造者模式

>将一个复杂对象分解为多个简单的对象，然后分别进行实现。将不变和变相分离，即组成部分是不变的，而每一部分都是可以灵活选择的。
>
>优点：
>
>1. 封装性好，构建和表示是分离的；
>2. 扩展性好，各个具体的建造者相互独立，有利于系统的解耦；
>3. 客户端不必知道产品的内部组成细节，建造者可以对创建过程逐步细化，而不对其他模块产生任何影响，便于控制细节风险
>
>缺点：
>
>1. 产品的组成部分必须相同，这限制了其使用范围
>2. 如果产品的内部变化复杂，且产品内部发生变化，则建造者也要同步修改，后期维护成本较大；
>
>建造者模式与工厂模式相比：
>
>1. 建造者模式更加注重零部件的组装过程
>2. 工厂模式更注重零部件的创建过程

## JVM

### 1.JVM的主要组成部分及其作用

> JVM主要由两个子系统、两个区域构成
>
> 1. 类加载器
>
>    主要作用是：将class文件加载到运行时数据区的方法区中
>
> 2. 执行引擎
>
>    包含JIT即时编译器、垃圾收集器、解释器Interpreter
>
>    主要作用是：将字节码文件编译为主机所使用的机器语言，并完成内存的回收工作
>
> 3. 运行时数据区
>
>    是JVM的内存区域
>
>    主要包括：
>
>    1. 程序计数器
>    2. 虚拟机栈
>    3. 本地方法栈
>    4. 堆
>    5. 方法区
>
> 4. 本地接口
>
>    与本地方法库进行交互，执行本地方法
>
> .java文件：由java源码编译器编译为class文件
>
> .class文件：由类加载器加载到运行时数据区的方法区，然后由JIT即时编译器编译为本机对应的机器语言

### 2.类加载器

> 作用：将class文件加载到运行时数据区的方法区

#### 2.1类加载的过程

> 包含以下几个阶段
>
> 1. 加载
>
>    1. 根据给定的全限定名找到对应的class文件的二进制字节流
>    2. 将二进制字节流的静态数据结构转换为方法区所需的数据结构
>    3. 在内存中创建对应的java.lang.Class对象，通过该对象可以对方法区的该类对应的各种数据进行访问和操作
>
> 2. 验证
>
>    作用：检验字节码中的内容是否符合JVM的规范、是否会对JVM造成损害
>
>    1. 文件格式验证
>
>       校验字节码文件是否符合java文件的规范
>
>    2. 元数据校验
>
>       主要是对字节码文件的内容进行语义校验，以确保字节码文件符合java文件的规范
>
>    3. 符号引用校验
>
>       来确保解析动作可以成功执行
>
>    4. 字节码验证
>
>       主要是通过数据流和控制流校验，确保程序的语义是合法的、是符合逻辑的
>
> 3. 准备
>
>    为类中的静态字段申请空间
>
> 4. 解析
>
>    主要是将符号引用转换为直接引用
>
>    1. 符号引用
>
>       就是使用符号表示对象，只要不会产生歧义，任何符合规范的符号都可以拿来使用
>
>    2. 直接引用
>
>       直接指向目标的指针、相对偏移量或间接定义到目标的句柄
>
> 5. 初始化
>
>    1. 使用new实例化一个对象
>    2. 调用静态方法
>    3. 设置或调用静态变量
>    4. 使用java.lang.Reflect实现反射调用，若当前类没有被实例化，则先对其进行实例化
>    5. 对子类进行初始化时，需要先对其父类进行初始化
>    6. JVM启动时，需要事先指定一个主类，JVM首先会初始化该类，若没有指定，则会抛出ClassNotFoundException的异常
>
> 6. 使用
>
> 7. 卸载
>
>    卸载时需要满足三个条件
>
>    1. 当前类的所有实例对象均已被回收
>    2. 当前类的所有类加载对象均已被回收
>    3. 当前类的Class对象没有在任何地方被调用，也无法在任何地方对其进行反射调用

#### 2.2类加载的分类

> 1. 引导类加载器bootstrap classloader
>
>    1. 由c或c++实现，在JVM的内部，主要用来加载JVM需要的核心类库
>    2. 没有父加载器，不继承自java.lang.Class类
>    3. 考虑到安全性，只加载java、javax、sun等开头的类库
>
> 2. 扩展类加载器 extends classloader
>
>    1. 由java语言编写完成
>    2. 继承自ClassLoader类
>
> 3. 系统类加载器 system classloader
>
>    1. 继承自ClassLoader类
>    2. 父加载器为扩展类加载器
>    3. 是程序的默认加载器，可以通过ClassLoader.getSystemClassLoader()获取
>
> 4. 用户自定义类加载器 user-define classloader
>
>    作用和目的：
>
>    1. 用于隔离加载器
>    2. 修改类加载的方式
>    3. 扩展加载源
>    4. 防止泄露源码

#### 2.3类加载的机制

> 1. 全局委派机制
>
>    > 所有的加载任务都交由父加载器去加载，只有父加载器无法对其进行加载时，才由当前加载器去完成加载
>
> 2. 缓存机制
>
>    > 若当前类已经被加载到缓存中，则直接取用；否则调用加载器对其进行加载，然后存储到缓存中；
>
> 3. 双亲委派机制
>
>    > 将加载任务交由父加载器进行加载，若父加载器仍有父加载器，则继续向上提交（向上委派）；
>    >
>    > 若附加在其无法完成加载任务，则由当前加载器完成加载任务。
>    >
>    > 若均无法完成加载任务，则抛出ClassNotFountException的异常
>    >
>    > 优点：
>    >
>    > 1. 因为父加载器加载过的类子加载器可以直接使用，所以避免了重复加载的出现
>    > 2. 避免了因为类名相同而导致的自定义类替代内部类的现象出现
>    >
>    > 缺点：
>    >
>    > 1. 父加载器无法使用子加载器加载的类

### 3.执行引擎

> 由三个部分组成，主要作用是将运行时数据区的方法区中的字节码文件编译成本机对应的机器语言
>
> 1. JIT即时编译器
> 2. 解释器Interpreter
> 3. 垃圾收集器Garbage Collections

#### 3.1 JIT compiler即时编译器

> HotSpot VM中的JIT compiler即时编译器的会生成汇编语言，保存在方法区的JIT缓存区。
>
> 主要分为两种
>
> 1. client编译器
>
>    会对字节码文件进行简单、可靠的优化，以便提升编译效率。注重的是局部优化，放弃耗时较久的全局优化。
>
> 2. server编译器
>
>    会对字节码文件进行更彻底、更激进的优化，耗时较久，但是优化后的效率更高。注重的是全局的、充分的优化；

#### 3.2 解释器Interpreter

> 解释器的作用和即时编译器的作用类似，即时编译器是解释器的替代品，因为解释器的目的就是将字节码文件翻译为主机所使用的机器语言，但是解释器的效率比较低，所以后续又提出了即时编译器替代，来解决效率问题
>
> 主要分为两类
>
> 1. 字节码解释器
>
>    使用纯代码模拟字节码的执行，效率低下
>
> 2. 模板解释器
>
>    将每一条字节码与一个模板函数相关联，模板函数直接产生这条字节码文件执行时的本地机器码，从而大幅提升解释器的性能
>
> 在HotSpot VM中，解释器由两部分组成
>
> 1. Interpreter模块
>
>    实现了解释器的核心功能
>
> 2. code模块
>
>    用于管理HotSpot VM在运行时生成的本地机器指令

### 4.JVM的内存区域（运行时区域）

> JDK1.8之前：
>
> 1. 线程共享：堆、方法区
> 2. 线程私有：程序计数器、虚拟机栈、本地方法栈
>
> JDK1.8开始：
>
> 1. 线程共享：堆、方法区、直接内存
> 2. 线程私有：程序计数器、虚拟机栈、本地方法栈

#### 4.1程序计数器

> 主要作用有两个
>
> 1. 标记当前指令指向的位置
> 2. 多线程情况下，当出现线程的上下文切换操作时，保存当前线程的执行位置，等到下一次获得处理器资源时可以继续操作
>
> 需要注意的是：
>
> 1. 程序计数器的生命周期和线程一致
> 2. 程序计数器不会出现outofmemory的异常

#### 4.2虚拟机栈

>主要用来存储本地变量或部分计算结果。方法的执行过程实际上就是虚拟机栈不断进行入栈和出栈操作的过程。
>
>需要注意的是：
>
>1. 虚拟机栈内的数据不能直接操作，必须要以栈帧的形式入栈出栈才行
>2. 虚拟机栈的生命周期和线程一致
>3. 虚拟机栈的大小可以在初始化时直接定死，也可以设置最大最小值，然后动态调节。
>4. 虚拟机栈的大小不可改变，所以可能会出现outofmemory、stackoverflowerror的现象
>
>虚拟机栈主要包含三个部分：
>
>1. 局部变量表
>
>   > 1. 基本存储单位是栈槽，每个栈槽可以存储一个boolean、char、int等变量，或使用两个栈槽存储long、double类型的变量
>   > 2. 可以使用索引进行访问，索引从0开始，但是索引为0的位置是当前实例本身，也就是this，所以其他变量的索引从1开始；另外，因为long、double需要使用两个栈槽存储，所以有时会出现索引位置为n的变量可以加载，但是n+1的位置不能加载
>   >
>   >
>
>2. 操作数栈
>
>   是一个后进先出的栈，每个条目可以存储JVM的任何类型的值，long和double需要两个条目进行存储
>
>3. 动态链接
>
>   作用是将变量、方法的符号引用转换为直接引用
>

#### 4.3本地方法栈

> 作用和虚拟机栈类似，但是
>
> 1. 虚拟机栈主要用来帮助JVM执行java方法
> 2. 本地方法栈主要用来帮助JVM执行native方法

#### 4.4堆

> 在虚拟机启动时创建，用来存放实例对象，由线程共享。
>
> 针对堆的内存区域，可以对其进行按代划分：
>
> 1. 新生代Young Generation
>
>    可以被划分为三个部分
>
>    1. Eden
>    2. S0
>    3. S1
>
> 2. 老年代Old Generation
>
> 3. 永久代 Permanent Generation
>
>    存储class的相关数据，如方法、字段等
>
>    在JDK1.8被移除，使用元空间存储
>
>    > MetaSpace元空间，不属于堆而属于本地内存，所以不会出现OutOfMemory的问题，但是也需要注意，否则会占用大量的内存。
>    >
>    > 使用元空间替代永生代的原因：
>    >
>    > 1. 因为class对象的大量数据都存储在永生代内存中，非常容易造成性能瓶颈和内存溢出的问题；
>    > 2. 永生代内存的大小不好进行设置，太小的话容易内存溢出，太大的话则会挤占老年代内存的空间而导致老年代内存溢出。
>    > 3. 对永生代内存进行GC的难度太大，需要对其进行特殊处理，比较复杂，且回收率不高。
>    > 4. 在JDK8时，合并了HotSpot和JRockit的代码，HotSpot的JVM有永久代内存的设置，但是JRockit没有，为了协调，所以取消了永久代内存，换成了存在于直接内存的元空间
>    >
>    > 使用元空间也不能完全避免内存溢出现象的出现，默认当前剩余内存容量为元空间最大容量，也可以自行设置。
>
> 新生代内存和老年代内存之间的相互转换
>
> 1. 对象首先来到新生代的Eden区，若Eden区域内存不足，则执行Minor GC；
> 2. 在Minor GC执行结束后，将Eden和S0中还存活的对象转移至S1中；
> 3. 若S1的内存不足，则将达到年龄限制的对象转移到老年代内存中；
> 4. 大对象直接放到老年代内存中；
> 5. 若老年代内存不足，则执行Major GC；
> 6. 若执行垃圾收集后，Eden仍没有足够的内存，则抛出OutOfMemory的错误
>
> 需要注意的是，在HotSpot中，年龄限制的设置规则如下：
>
> > 默认是MaxTeurningThreshold，首先将所有存活对象根据年龄进行排序，然后依次进行遍历，计算累计内存占用量。当遍历到年龄x时，累计内存占用超过容量的一半，则获得年龄限制=min(x，MaxTeurningThreshold)

#### 4.5方法区

> 方法区的主要作用是存储类信息、常量、静态变量、JIT即时编译器的结果等信息
>
> 方法区和执行引擎之间的关系类似于接口和实现类之间的关系。
>
> 方法区是java虚拟机规范的定义
>
> 执行引擎是java虚拟机规范的实现。

#### 4.6运行时常量池

>是字节码文件常量池在运行时的表示，主要分为符号引用和字面量。

#### 4.7直接内存

>就是本机的内存。
>
>在JDK4时，引入了NIO，因此具有了基于通道和缓存的IO方式，所以可以使用本地函数库直接分配堆外内存，然后通过一个存储在JVM堆中的DirectByteBuffer对象作为这块内存的引用进行操作。
>
>可以在某些场景下提升性能，因为避免了从本地堆和JVM堆之间传输数据。

### 5.java对象的创建过程

#### 5.1 类加载检查

>其实就是检查当前类是否完成加载，没有完成加载的话，则需要执行类加载的加载、验证、准备、解析的过程。
>
>1. 当使用new关键字得到实例化对象后，
>2. 首先检查这个指令的参数否可以在常量池中找到
>3. 然后检查符号引用是否被加载、验证、准备、解析过
>4. 没有的话，则需要进行加载、验证、准备和解析。

#### 5.2 分配内存

>主要就是将JVM堆的空间划分一块出来。
>
>主要有两种方式：
>
>1. 指针碰撞
>
>   在可用空间和已占用空间设置一个指针，分配多少空间指针就移动多少即可。
>
>   缺点是：每次清除空间都会引起大量数据移动，影响效率。
>
>2. 空闲列表
>
>   就是将所有可以使用的内存空间地址存储在一个列表中，需要分配空间时，找到一个大小合适的空间进行分配即可。
>
>   缺点是：因为不可能每次都恰恰好好，所以会产生大量内存碎片
>
>==内存分配的并发问题的解决策略：==
>
>1. 使用CAS+失败重试解决
>
>   因为CAS是乐观锁的一种，所以当失败后，继续尝试进行分配
>
>2. 使用TLAB（Thread local associate buffer本地线程分配缓存）解决
>
>   具体是在Eden中事先为每一个线程分配一块区域，若TLAB可以存储，则使用TLAB存储；当占用空间大于TLAB或大于TLAB的剩余空间时，再使用CAS+失败重试的策略
>

#### 5.3 初始化零值

>就是将已经分配的内存空间全部置为0，目的是为了在不进行初始化的情况下也可以对其进行调用。

#### 5.4 设置对象头

>将当前类相关的信息（对象属于哪个类、对象的hashcode等）嵌入到对象头中，不同的虚拟机对象头的内容和嵌入方式都不同。

#### 5.5 执行init方法

>对于JVM而言，此时对象已经完成初始化；
>
>而对于java程序而言，对象的初始化刚刚开始，需要根据程序员的意愿对对象进行初始化，执行init方法

### 6.对象的定位和访问方式

> 主要有两种：
>
> 1. 句柄
> 2. 直接指针

#### 6.1 句柄

> 基本流程是：
>
> 1. 本地变量表的reference存储句柄的地址
> 2. 句柄存储实例数据的地址和类型数据的地址
>
> 优点：当引用发生改变，只需要改变reference的指向即可，无需改变其他的
>
> 缺点：找到对象的全部信息需要进行3次寻址，效率较低
>
> ==实例数据在JVM堆的实例池中，类型数据在运行时数据区的方法区中；==

#### 6.2 直接指针

> 基本流程是：
>
> 1. 本地变量表的reference存储实例数据的地址
> 2. 实例数据的地址指向的内存空间存储着实例数据和存储类型数据的地址
>
> 优点：只需要两次寻址就可以获取对象的全部信息
>
> 缺点：需要想办法将实例数据和存储类型数据的地址存放在一起

### 7.jvm的内存分配和回收

>Java的内存自动管理功能实际上是对java内存的分配和回收，核心是对JVM堆空间的分配和回收。

#### 7.1内存分配和回收的过程

>新生代分为简单可以分为两部分Eden和Survivor，大小为8:2，默认情况下，S1中的对象每熬过一次GC，年龄增长一岁。
>
>分配和回收的过程：
>
>1. 第一次GC之前，S1是空的；
>2. 将对象放在Eden和S0中
>3. 进行一次Minor GC
>4. 将Eden和S0中存活的对象转移至S1中，并将S1中所有对象年龄加1
>5. 将S1中达到年龄限制MaxTeruingThreshold的对象转移到老年代内存中；
>6. 将S0和S1互换身份，回到步骤2
>7. 当S1满了之后，将所有对象放到老年代中；当遇到大对象，直接放到老年代中
>
>遇到大对象直接放到老年代中的原因：
>
>> 主要是为了避免对大对象的分配担保机制影响效率。

#### 7.2GC的分类

>按代进行划分
>
>1. Young GC/ Minor GC
>
>   针对新生代进行回收
>
>2. Old GC/ Major GC
>
>   针对老年代进行回收
>
>3. Full GC
>
>   针对新生代和老年代的部分区域进行回收。需要注意的是，在某些语境下，Major GC同样是Full GC的意思。

#### 7.3内存分配担保机制-HandlePromoteFailure

>新生代转移到老年代内存时，
>
>1. 首先判断老年代的剩余空间是否大于新生代的总空间（因为可能整个新生代的对象都要传到老年代中）
>2. 若空间不足，则检查是否开启内存分配担保机制
>   1. 开启了，首先检查老年代剩余内存是否大于历次跨代转移的平均大小
>      1. 若大于，则执行Minor GC，但此时是有风险的，因为不确定究竟有多少对象要到老年代中
>   2. 若没有开启或小于，则执行一次Full GC，将老年代清空

#### 7.4垃圾收集算法

>1. 标记清除
>
>   首先将所有不需要清除的对象进行标记，然后清除所有没有标记的对象
>
>2. 复制清除
>
>   将内存空间分为两半，只使用一半存储对象，每次GC执行后，将当前一半仍存活的对象转移到另一半中，互换两半的角色
>
>3. 标记整理
>
>   与标记清除类似，但是标记完成后，则是将所有被标记的对象移到一个方向，然后清除剩余的部分
>
>4. 分代清理
>
>   在新生代使用复制清除算法，因为新生代每次GC需要清除大量的对象，复制清除算法速度最快
>
>   在老年代使用标记清除或标记整理算法。

#### 7.5垃圾收集器

##### 7.5.1Serial收集器

>串行、单线程的垃圾收集器
>
>在单线程下表现较好，因为无需考虑线程切换的开销

##### 7.5.2ParNew收集器

>是Serial收集器的多线程版本，除了使用多线程进行处理，其余参数设置与Serial相同

##### 7.5.3Parallel Scavenge收集器

>多线程的收集器
>
>与CMS等注重用户停顿时间的收集器不同，Parallel Scavenge收集器注重吞吐量。

##### 7.5.4Serial Old收集器

>单线程，是Serial收集器的老版本
>
>作用
>
>1. 在JDK4及之前，和Parallel Scavenge收集器搭配使用
>2. 目前作为CMS的备选收集器

##### 7.5.5Parallel Old收集器

>多线程，是Parallel Scavenge收集器的老版本，同样注重吞吐量

##### 7.5.6CMS收集器

>多线程、注重用户停顿时间的垃圾收集器
>
>实现步骤：
>
>1. 初始标记
>
>   暂停其他所有线程，从GC Roots开始进行遍历，对所有相连的对象进行标记（与root相连表示是存活对象）
>
>2. 并发标记
>
>   同时启动GC线程和其他用户线程，采用一个闭包结构对所有存活对象进行标记。
>
>   因为用户线程也在运行，所以引用指向也是随之变化的，GC不能保证所有存活对象都已经被标记，所以会跟踪记录这些变化。
>
>3. 重复标记
>
>   暂停其他线程，重新进行标记
>
>   主要的目的是为了修正因为用户线程不断运行而导致的引用发生的变化。
>
>   该过程的停顿时间比步骤1要长，但是比步骤2要短
>
>4. 并发清除
>
>   开启用户线程，同时开启GC线程对所有被标记的对象进行内存回收。
>
>优点：
>
>1. 并发度高，停顿时间短
>
>缺点：
>
>1. 对CPU资源敏感
>2. 无法处理浮动垃圾
>3. 因为在老年代采用了标记清除算法，所以会产生大量内存碎片
>
>需要注意的是：
>
>> CMS使用Card Table+write barrier的方式，将老年代内存分为多个大小相同的块，每个块就是一个Card Page，Card Table的每一个条目对应一个Card Page。
>>
>> 在CMS中，有一块区域用来记录老年代中的每个 Card 指向新生代的引用（`points-out` 结构），在进行 YGC 时，这一块区域的对象作为 GC roots，而不需要扫描整个老年代（YGC 时需要知道哪些新生代对象是被老年代引用的，所以需要扫描老年代内存）。
>>
>> 并发标记时，若对象的引用发生了写操作也就是被修改了，那么write barrier会将当前Card Page标记为dirty。
>>
>> 进行YGC时，只需要扫描标记为Dirty的Card Page即可找到被老年代跨代引用的对象，无需扫描整个老年代。

##### 7.5.7G1收集器

>多线程、并发、停顿时间短的垃圾收集器，比较适合多处理器的服务器端的虚拟机
>
>特点：
>
>1. 并发和并行
>
>   与CMS等需要暂停其他线程的收集器不同，G1可以利用并发性，与用户线程一起运行。
>
>2. 分代收集
>
>   虽然G1一个收集器就可以完成对整个JVM的内存回收工作，无需其他收集器的配合，但仍旧保留了分代的概念。为每一个Region设置一个状态，如Eden、Survivor、Old、Humongous，这些状态的Region不一定是物理连续的，并且每个Region的状态也不是不变的。对于较大的对象（大小超过Region的一半），直接放到Humongous Region（巨型区域）。
>
>3. 空间整合
>
>   G1在整体上看是采用了标记整理算法，在局部采用的是复制算法。
>
>   先把对象存在Eden和Survivor状态的Region，进行GC后，将存活的对象复制到一个新的Survivor中，因此不会产生内存碎片。
>
>4. 可预测的停顿时间模型
>
>   虽然CMS和G1等收集器都是注重用户停顿时间，但是G1存在一个可预测的停顿时间模型，用户可以显式的指定停顿时间，G1会选择性价比最高的若干个Region进行内存回收。
>
>   G1在内部维护一个优先队列，按照Region中失效对象的比例进行排序。
>
>RSet
>
>> 每个Region对应一个Remembered Set，用来存储Region之间的对象引用关系（谁引用了我，我引用了谁），当进行YGC时，只需要根据RSet的内容就可以获取老年代跨代引用的新生代的对象，无需扫描全部的老年代对象。
>
>G1采用YGC+MIX GC的方式进行收集，没有使用Full GC，使用了Serial Old GC实现了Full GC的效果。
>
>MIX GC
>
>> 扫描的区域是新生代+部分老年代
>>
>> 1. 针对不存在对象的Region，直接添加到Collection Set中
>> 2. 针对存在对象的Region，G1会根据可预测的停顿时间模型和优先队列，选择性价比最高的Region进行回收。
>
>增量式回收
>
>>体现在G1可以和Mutator交替执行。
>
>三色标记法
>
>>主要是将正在搜索的对象标记为灰色、已经搜索完的对象标记为黑色、未进行搜索的对象标记为白色。
>
>SATB
>
>>即snaphot-at-the-begin，在GC开始前，记录对象的快照。
>>
>>当堆内存空间使用率超过InitialHeapOccupancyPercent时，开始标记，使用SATB记录标记开始阶段的对象快照
>
>G1的运行步骤
>
>>1. 初始标记
>>
>>   暂停其他线程（STW操作 stop-the-world）
>>
>>   从GC Roots出发，将所有与Roots直接相连的对象存入扫描栈，等待后续扫描。
>>
>>2. 根区域扫描
>>
>>   不是STW操作，并发
>>   从Survivor区域中的对象开始进行扫描，找到老年代中引用的对象，然后将其存入栈中
>>
>>   YGC开始之前，根区域扫描必须要完成
>>
>>3. 并发标记
>>
>>   不是STW操作，且YGC可以打断该操作
>>   根据栈中的对象，递归扫描所有对象，把扫描到的对象加入到栈中，直至栈为空。
>>
>>4. 最终标记
>>
>>   STW+并发
>>
>>   暂停其他线程，将SATB Buffer中存在的引用进行标记
>>
>>5. 清除
>>
>>   STW+并发
>>
>>   首先清点出有存活对象的region和没有存活对象的region
>>   然后更新Rset
>>   把没有存活对象的Region收集到可分配的Region队列中。

### 8.如何判断对象是否存活？

>1. 引用计数法
>
>   为每一个对象分配一个计数器，当被引用了计数器加一，当引用失效则计数器减一
>
>   计数器为0的对象不可被引用
>
>2. 可达性分析
>
>   从若干个被称为GC Roots的对象出发，进行遍历，相连的路径被称为引用链。
>
>   若一个对象与GC Roots之间没有任何可达路径，则判定该对象失效

### 9.如何判断常量是否是废弃常量？

>运行时常量池的GC操作主要是回收常量的内存空间。
>
>当一个常量不再被引用，则就被认定是废弃的常量，当进行GC且有必要的话，可以对其进行内存回收。

### 10.如何判断类是无用的类？

>和类加载的卸载判定类似，若当前类同时满足下面三个条件，则被判定为无用类，可以对其进行回收，但不是必须回收。
>
>1. 当前类的实例对象均已被回收
>2. 当前类的ClassLoader均已被回收
>3. 当前类的java.lang.Class对象不可以进行反射调用

## 计算机网络

### 1.OSI七层架构和TCPIP五层架构

> OSI七层架构主要包含：
>
> 1. 应用层
> 2. 表示层
> 3. 会话层
> 4. 运输层
> 5. 网络层
> 6. 数据链路层
> 7. 物理层
>
> TCPIP五层架构主要包含：
>
> 1. 应用层
> 2. 运输层
> 3. 网络层
> 4. 数据链路层
> 5. 物理层
>
> 其中
>
> 1. 物理层==比特流==
>
>    作用：在相邻主机节点之间完成比特流的透明传输
>
>    传输单位：。使用比特流进行传输的主要原因是为了消除不同介质之间存在的差异
>
> 2. 数据链路层==帧==
>
>    作用：将网络层的IP数据报封装成帧，在节点的相邻链路之间进行传输
>
>    帧中包含数据信息和控制信息，接收端可以根据控制信息将数据信息提取出来交给网络层。
>
> 3. 网络层==IP数据报==
>
>    作用：将运输层传下来的用户数据报或报文封装为分组或包，找到合适的网间路由或交换节点来确保数据的及时传输。
>
>    注意：
>
>    在TCPIP体系下，网络层采用的是IP协议，所以封装的数据都叫IP数据报
>
> 4. 运输层==报文==
>
>    作用：负责向两台主机的进程提供可靠的数据传输服务。
>
>    > 复用：允许多个进程同时使用运输成传输数据；
>    >
>    > 分用：运输成可以将收到的信息分别交付给应用层中的不同进程；
>
>    > TCP：传输控制协议，面向连接的、可靠的传输协议。
>    >
>    > UDP：用户报文协议，无连接的、尽最大努力的数据传输协议，不能保证可靠性。
>
> 5. 应用层==报文==
>
>    作用：通过应用进程之间的交互通信完成特定的网络应用。
>
>    应用层协议是应用程序之间通信和交互的规范。
>
>    > DNS：域名解析服务器。将域名和ip地址绑定在一起的分布式服务器，域名一般都是公司名，所以人们不用记ip数字串。
>    >
>    > HTTP：超文本传输协议，所有的万维网www都必须遵从该协议；

### 2.TCP的三次握手

> 1. 客户端向服务器端发送连接请求（SYN=1，seq=x）
>
> 2. 服务器端向客户端发送连接确认应答（SYN=1，ACK=1，seq=y，ack=x+1）并进入==半连接状态==；
>
>    客户端收到确认请求，进入==Establishd状态==
>
> 3. 客户端向服务器端发送确认应答（ACK=1，ack=y+1），服务器端收到确认请求，进入==Established状态==
>
> 其中涉及了==SYN-ACK机制==
>
> > SYN是握手
> >
> > ACK是应答
> >
> > seq是序号，ack是确认号，ack=序号+1
>
> ==不使用两次握手的原因==
>
> > 主要是防止客户端失效的请求连接报文到达服务器端而引起的不必要的错误。
> >
> > 如果使用两次握手，那么只要服务器端收到请求报文就会建立连接，当收到的是失效的报文的话也会建立连接，会导致服务器资源的浪费。
> >
> > 如果使用三次握手，即便失效的客户端连接请求报文达到了服务器端，因为客户端不会对服务器端的确认信息进行应答，所以服务器端也不会进入连接状态，从而避免了浪费。

### 3.TCP的四次挥手

> 1. 客户端向服务器端发送断开连接请求（FIN=1，seq=x），==客户端  Established ——》FIN-WAIT-1==
>
> 2. 服务器端向客户端发送确认应答（ACK=1，seq=y，ack=x+1），==服务器端Established ——》CLOSE-WAIT==
>
>    ==客户端收到确认应答后，FIN-WAIT-1 ——》FIN-WAIT-2==
>
> 3. 服务器端向客户端发送连接断开确认应答（FIN=1，seq=w，ack=x+1），==服务器端CLOSE-WAIT ——》LAST-ACK==
>
> 4. 客户端向服务器端发送确认应答（ACK=1，seq=z，ack=w+1），==客户端FIN-WAIT-2 ——》TIME-WAIT==
>
>    ==服务器端接收到客户端的确认应答后，LAST-ACK ——》CLOSED==
>
> 5. 客户端在TIME-WAIT等待2MSL后，进入CLOSED状态，至此连接断开。
>
> ==ESTABLISHED、TIME-WAIT、CLOSE-WAIT状态==
>
> > ESTABLISHED表示正在通信状态
> >
> > TIME-WAIT表示主动关闭连接
> >
> > CLOSE-WAIT表示被动关闭连接
>
> ==TIME-WAIT的等待时间为2MSL的原因==
>
> > 1. 主要是为了防止客户端最后发送的确认应答服务器端接收不到，因为MSL是报文最大生存时间，所以2MSL内，若服务器端接收不到客户端的确认应答，会再次重发，等待期间就可以发现这一问题，因此客户端可以再次重发确认应答，然后再等待2MSL
> > 2. 为了防止三次握手期间的失效连接请求报文突然到达服务器端，等待2MSL后，本客户端产生的所有报文均已失效，从而避免了这种问题。
> > 3. 因为TCP的端口不能同时打开，所以为了避免在断开连接后立刻连接却接到上一次连接的报文，等待2MSL后可以保证当前连接过程产生的所有报文都已失效。
> > 3. 因为2MSL大约4分钟，所以要尽量避免服务器端主动断开连接

### 4.TCP和UDP

|          |                TCP                 |                      UDP                       |
| :------: | :--------------------------------: | :--------------------------------------------: |
|          |       面向连接的、只支持单播       |         无连接的，支持单播、多播、广播         |
|  可靠性  |               可靠的               |                  不保证可靠性                  |
|   效率   |  较低（因为要进行握手和挥手操作）  |                      较高                      |
| 应用场景 | 需要保证可靠性的场景，如文件传输等 | 需要传输大量信息的场景，如直播推流、视频播放等 |
| 首部字节 |             20-60字节              |                     8字节                      |

### 5.UDP的头部信息

占8个字节，主要分为四个部分

1. 源端口号
2. 目标端口号
3. 整个报文段的长度
4. 校验和：用于校验头部和数据信息的完整性

### 6.TCP的头部信息

占20-60个字节，其中40个字节是可选的

20个字节主要组成部分：

1. 源端口号

2. 目标端口号

3. 序号seq

   是指当前报文是当前连接的中传输数据的那一段。

   假设连接创建时，开始编号被随机为ISL，当传输第1024-2048字节的数据时，序号为ISN+1024

4. 确认号ack

   等于序号+1，用于确认应答报文

5. 头部长度--4位

   因为TCP的头部长度是不确定的，所以需要表明头部长度

6. 待使用空间--6位

7. 标志位--6位

   1. URG：表明紧急指针是否有效
   2. PSN：表明要求接收方清空TCP报文缓冲区，为后续报文腾出空间
   3. RST：表明需要重发报文
   4. ACK：表明当前报文是确认应答报文
   5. SYN：表明当前报文是请求连接报文
   6. FIN：表明当前报文是连接释放报文

8. 窗口大小

   向发送方反馈接收方的接受情况，发送方会根据确认应答的窗口大小及时调整接下来发送窗口的大小

   用于流量控制

9. 校验和

   用于校验头部信息和数据信息的完整性

10. 紧急指针

    是需要的偏移量，是一个正值。

    当需要传输紧急数据时使用，此时正常数据的序号=序号+紧急指针

### 7.TCPIP如何确保可靠性

1. TCP将数据切分成合适的大小，然后分段发送

2. TCP为分段的报文进行编号，接收方会根据编号对报文进行排序，只会对有序的报文确认应答；

3. TCP的头部中包含校验和，可以保证TCP报文数据的完整性，接收方不会对错误的报文进行确认应答；

4. TCP会直接丢弃重复的报文，但是会对这些报文发送确认应答，以避免发送方重复发送这些报文；

5. 流量控制

   发送方和接收方共同商议发送窗口的大小，以此实现流量控制

6. 拥塞控制

7. ARQ协议

8. 超时重传

   当发出报文后。发送方会启动计时器，当计时器过期时仍没有接到确认应答，会再次重发该报文。

### 8.ARQ协议

就是自动重传协议。

根据确认和超时机制，完成报文的超时重传，保证了数据的完整性。

主要分为两大类

1. 停止等待ARQ

   发送一个报文，启动计时器，计时器过期时仍没有受到确认应答则重发。否则发送下一条报文

2. 连续ARQ

   分为两种方法

   1. 回退N帧的连续ARQ

      因为接收方只会对有序的最后一条报文进行确认，所以发送方会重发确认报文后面的所有报文

   2. 选择重发的连续ARQ

      缺少那条补那条

### 9.拥塞控制

目的：在网络拥塞时减少发送的数量以减少网络拥塞程度。

四种算法：

1. 慢开始

   在连接刚刚建立或拥塞后重新连接时，将拥塞窗口的大小设置为1，每完成一个轮次（发送报文到受到确认应答），窗口大小+1

2. 拥塞避免

   在该阶段，每经过一个RTT，拥塞窗口大小+1

3. 快重传

   当遇到某一个报文乱序时，接收方会对有序的最后一个报文立即发送重复确认应答，而不是在发送其他报文时捎带发送。

   当发送方受到连续三个重复确认报文时，会停止已有的报文发送顺序，立即发送缺少的报文。

   如在发送1-6号报文时，缺少3号报文，接收方会对2号重复确认，然后发送方在接到三次重复确认报文后，立即发送3号报文，接收方在收到3号报文后，再对6号报文发送确认应答

4. 快恢复

   当出现拥塞的情况，首先将拥塞窗口的大小进行乘法减少，即大小减半，然后根据拥塞窗口的大小选择增大方式（主要是根据ssthresh的值，若ssthresh>cwnd，则使用慢开始的方式，每轮次+1；若ssthresh<cwnd，则使用拥塞避免的方式，每经过一个RTT+1）

### 10.HTTP各版本（1.0，1.1，2.0，HTTPS）之间的区别

#### HTTP 1.0

优点：

1. 简单易懂
2. 扩展性强，错误信息可以自定义
3. 可跨平台

存在的问题：

1. 无状态

   无法保存当前连接的相关信息，但是可以使用cookie、session、token等方式保存

2. 不安全

   主要体现在使用明文传输、不确认通信对象的真实性、不保证数据的完整性

3. 无连接

   采用无连接的方式，因此每次传输数据都要进行连接、使用、释放，效率低

#### HTTP 1.1

改进点：

1. 缓存处理优化

   HTTP 1.0仅使用expires等处理缓存

   HTTP 1.1 新增了很多缓存处理的方式

2. 带块优化和网络连接优化

   HTTP 1.0 请求数据时只能返回整个对象

   HTTP 1.1 在头部信息中增加了range参数，因此可以只返回部分数据

3. 错误信息增多

   HTTP 1.1新增了24个错误状态码

4. 头部信息处理

   HTTP 1.0 因为默认每个IP地址对应一个主机，所以URL中没有包含主机信息

   HTTP 1.1 的URL中必须包含hostname，否则会报错 400 bad request；这是因为随着虚拟技术的发展，每个IP地址下可以存在多个主机，不指定hostname的话找不到对应的主机进行处理

5. 长连接

   HTTP 1.0 使用短连接，每次传输数据都需要建立连接

   HTTP 1.1 使用长连接，建立连接后会持续一段时间，之后的数据传输无需再建立连接即可使用。

6. 通道传输

   因为HTTP 1.1使用的是长连接，因此可以使用通道传输，长连接的通道传输主要有两种方式：

   1. 流水线方式：不用等待上一个请求的响应，直接发送下一个请求
   2. 非流水线方式：只有在接到上一个请求的响应后才会发出下一个请求

存在的问题：

HTTP 1.1是串行处理请求的，所以当队列店面的请求处理较长时间时，后续的请求会等待较长时间，产生——队列阻塞的问题。

#### HTTP 2.0

1. 头部省略

   若连续多个请求的头部信息相同，则在传输过程中对其进行省略。

   HPACK算法：由发送方和接收方共同维护一个头部信息列表，只要出现重复的头部信息，就使用索引代替。

2. 二进制传输

   将数据以二进制字节流的格式传输，从而避免了计算机的再次转换，提升了效率。

3. 数据流

   将一个请求或响应的全部报文成为一个数据流，并对它们进行编号。

   一般情况下，客户端的编号为奇数，服务器端的编号为偶数

4. 多路复用

   允许在一个连接中并发处理多个请求或响应

HTTP 2.0移除了HTTP 1.1 的串行处理请求的机制，因此无需排队等待，避免了队头阻塞问题的出现。

#### HTTP的分块传输编码chunk

分块传输主要是Chunk传输编码，一般情况下，在使用gzip编码时才会使用chunk 传输编码。

具体就是将整块的数据分为若干段，然后进行传输。一般情况下，块的大小是一致的，但这个不是必须的。

好处：

1. 允许服务器为动态生成的内容实现持久性连接

   一般情况下，持久性连接需要事先在响应头中指明数据的长度content-length

   而动态生成的内容的长度是不可预知的，所以可以使用分块编码实现动态生成内容的持久性连接

2. 允许服务器在最后传输消息头

   对于一些头部字段内容在没有加载完整个内容无法获得的数据非常重要，例如对整个数据的哈希值。

   原本需要服务器完成对整个数据的加载才可以得到整个数据的哈希值，而分段传输可以先把数据内容发送，最后发送整段数据的哈希值。

3. 允许在使用数据压缩的时候，边压缩边传输数据。一般是和gzip搭配使用。

#### HTTPS

对于HTTP而言，基本结构为HTTP协议--TCP协议--IP协议--MAC协议，端口80/8080

对于HTTPS而言，在HTTP和TCP协议之间增加了SSL/TSL协议，端口443，对HTTP的明文数据进行加密，以此提升了安全性。

SSL（security socket layer）是安全套接层协议，1995年提出了3.0的版本。

TSL（transport security layer）传输层安全协议是在SSL 3.0的基础上提出的。

##### TSL--是加密框架

对TSL而言，可以分为TSL握手协议和TSL记录协议。

TSL握手协议由

1. 握手协议

   最重要的，作用是在通信双方之间协商加密方式、共享密钥等信息

2. 密码规格变更协议

   通知通信对象加密方式发生了改变

3. 警告协议

   负责在出现错误时通知通信对象

4. 应用数据协议

   负责将TSL承载的应用数据传输给通信对象



握手协议

在建立连接时，

1. 客户端向服务器端发送信息，其中包括
   1. 可使用的版本号
   2. 可使用的加密方案
   3. 可使用的压缩方案
   4. 会话编号
   5. 客户端随机数
   6. 当前时间
2. 然后服务器端选择版本号、加密方式、压缩方式等，返回给客户端，其中包括
   1. 选择的版本号
   2. 选择的加密方式
   3. 选择的压缩方式
   4. 会话编号
   5. 服务器端随机数
   6. 当前时间
3. 客户端向服务器端发送已经加密的密钥
4. 客户端向服务器端发送密码更改信息，表示后续的数据传输都会使用当前的密钥进行加密
5. 然后双方确认握手协议结束
6. 准备开启应用数据协议



TSL记录协议的主要作用是：对数据进行压缩、加密和数据的认证。

首先将数据进行分段，然后压缩，然后计算其信息验证码，最后使用对此密钥进行加密。



### 11.浏览器的缓存

浏览器的缓存缓存处理主要有两种方法：

1. 强制缓存

   在HTTP 1.0中，使用Expires实现强制缓存

   1. Expires是缓存的存活时间，是一个精确的时间值，服务器设置。

   2. 但是存在一个问题，就是它是服务器设置的时间点，如果客户端和服务器的时间不一致的话，就会导致客户端认为缓存没到期，直接取用缓存，但实际上缓存已过期，因此引发缓存命中错误的现象。

      

   在HTTP 1.1中，使用Cache-Control实现强制缓存，参数可以分为选择：

   1. public：表示所有对象均可以缓存数据
   2. private：表示只有客户端可以缓存数据
   3. no-cache：表示客户端可以缓存数据，但是是否使用缓存需要协商
   4. no-store：表示任何对象都不可以缓存数据，也不使用强制缓存和协商缓存

2. 协商缓存

   是指直接将请求发送到服务器，然后由服务器验证浏览器本地缓存数据是否可用，可用的话则使用本地缓存数据，否则从服务器获取

   可以分为两种方式

   1. Last-Modified/If-Modified-Since
      1. Last-Modified：服务器返回请求数据上次修改的时间
      2. If-Modified-Since：请求时，如果服务器发现请求报文中包含If-Modified-Since字段，就会返回上次请求过程中返回的上次修改时间，然后和本次Last-Modified的返回值进行对比，若相同，则表示两次请求之间数据没有发生变化，可以使用缓存中的数据；否则需要使用服务器的数据
   2. Etag/If-None-Match
      1. Etag：服务器返回请求数据的唯一标识（浏览器通过对比本地缓存数据的唯一标识，决定是否使用本地缓存数据）
      2. If-None-Match：请求时，如果服务器发现请求报文中包含If-None-Match字段，就会返回上次请求过程中返回的数据的唯一标识，然后和本次Etag的返回值进行对比，若相同，则表示两次请求之间数据没有发生变化，可以使用缓存中的数据；否则需要使用服务器的数据

3. Etag和Last-Modified的区别

   1. Last-Modified只能检测到秒级的修改，若是在一秒内的修改，只能使用Etag进行检测
   2. Last-Modified的效率更高，主要是因为只需要存储修改时间即可，而Etag还需要存储对象的唯一标识
   3. Etag和Last-Modified可以一起使用，但是Etag的优先级更高

### 12.如何理解HTTP协议的无状态

HTTP的无状态体现在不能保存当前连接的相关信息，如用户登录信息等，连续访问位于同一个服务器的同一个网站，两次的访问没有任何的关系。

其实HTTP的无状态并不能算得上是一个缺点，因为在早期，HTTP主要是用来访问静态资源网站的，无状态更能保证响应效率，并且可以减少服务器的开销，毕竟若是有状态的，网页不关闭连接也不关闭，会增大服务器开销。

但是可以使用Cookie、Session、token等来完善这一点。

Cookie

不安全，所以不能存储敏感信息，容易被人截获破解

实现步骤：

1. 浏览器提交请求
2. 服务器创建一个session对象，然后把对于的sessionid通过响应头的JSESSIONID传给浏览器
3. 浏览器建立一个JSESSIONID=xxx的cookie，浏览器向同一个服务器发送请求都会带上该cookie的信息
4. 服务器通过cookie的JSESSIONID信息找到对应的用户信息

若Cookie被浏览器禁用，SESSIONID会在URL中携带

Cookie的作用：

1. 保存用户信息等；
2. 保存个性化设置
3. 跟踪状态

Cookie的分类：

1. 会话Cookie：保存在内存中，浏览器一旦关闭就会永久丢失
2. 永久Cookie：生命周期与浏览器的关闭无关，仅于Expires或Cache-Control设置的过期时间相关



Cookie的作用域：

1. 通常通过Domain或Path设置，若没有设置，则其子域名也可以对其进行访问



Session

1. 本质上是一个ConcurrentHashMap，而sessionid可以看作是key
2. 因为sessionid可以看作是不可预测的，所以还是比较安全的
3. 因为用户信息等数据都需要存在服务器上，这意味着想使用session就要和上一次请求一样访问同一个服务器。但现在分布式和负载均衡是趋势，如果数据共享效率就太低了，所以可以使用token替代



token

1. 与Session是ConcurrentHashMap不同，token是一段字符串，其中包含所有的信息
2. 但是token需要存储在数据库中，每次请求时都需要到数据库中进行对比，效率还是比较低



JWT（JSON web token）

1. 和token一样，是一段字符串，但是不需要服务器保存这段字符串，只要保存密钥即可，验证由数据库信息比对，转换为解密，只要解密出的信息对的上就表示信息已经存在
2. 由三部分组成base64重编码的header、base64重编码的payload、签名Signature
3. header包含选择的加密算法和token类型
4. payload包含传输的信息
5. 签名Signature就是使用指定的加密算法和生成的密钥，将base64重编码的header、base64重编码的payload进行加密得到的密文结果
6. 然后将base64重编码的header、base64重编码的payload、签名Signature三部分使用"."分隔开即为JWT



JWT的特点：

1. 更安全

   因为使用了数字签名，所以更加安全

2. 无状态的

   因为JWT是存储在浏览器端的，每次发送请求时只要带上JWT即可，服务器端使用存储的密钥进行解密签名，只要解密结果可以和签名的base64重编码的header、base64重编码的payload对的上就表示对应的信息存在

3. 可扩展的

4. 支持跨域访问

   因为Session cookie机制需要在服务器端存储用户信息，所以只能在单点或子域中访问认证。

   而JWT的验证只需要解密成功即可，所以可以实现跨域认证操作

### 13.GET和POST方法的区别

GET和POST都是HTTP请求方式，存在的最大区别就是GET是用来获取服务器的数据的，而POST在获取数据的同时涉及到对服务器数据的增删改操作。

|              |                             GET                              |                             POST                             |
| :----------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   后退操作   |                         没有任何影响                         |              会重新提交数据，需要浏览器告知用户              |
|   编码格式   | application/xx-www-form-urlcode，对于空格使用+替代，对于特殊符号，使用ASCII HEX编码替代 | application/xx-www-form-urlcode或multipart/from-data，可以用来对 |
|    安全性    |             不安全，因为所有的信息都会显示URL中              |                    相较于GET要更安全一些                     |
|     参数     |                     会被保存在历史记录中                     |                     不会保存在历史记录中                     |
| 参数长度限制 | 因为GET的参数会显示在URL中，而URL的长度是有限制的，所以GET的参数长度也是有限制的。其实URL的长度是没有限制的，这些限制都是浏览器设置的。 |                           没有限制                           |
| 数据类型限制 |                      只能传输ASCII编码                       |             可以传输任意的编码，二进制编码也可以             |
|    可见性    |        因为数据会显示在URL中，所以对任何人都是可见的         |          不可见，因为数据是存储在请求体和响应体中的          |

### 14.HTTP的method

|  方法   |                             作用                             |
| :-----: | :----------------------------------------------------------: |
|  HEAD   |             作用和GET类似，用来获取请求头的数据              |
|   GET   |                        请求服务器数据                        |
|  POST   |      请求服务器数据，可能伴随着对服务器数据的增删改操作      |
|  TRACE  |        在浏览器回显服务器接收到的请求，用于测试和调试        |
|   PUT   |                      修改服务器中的数据                      |
|  PATCH  |       对PUT方法的补充和增强，用于对已知资源的局部更新        |
| CONNECT | 主要是HTTP 1.1中预留给可以将传输方式改为通道传输的代理服务器 |
| DELETE  |                        删除服务器数据                        |
| OPTIONS |                     浏览器查看服务器性能                     |

### 15.HTTP请求的报文格式

请求报文

1. 请求行

   包含：

   1. 请求方法
   2. 请求URL
   3. HTTP协议版本
   4. 请求头：由若干个键值对构成，服务器通过这些信息获得客户端的相关信息

2. 空行

   由一个回车符和一个换行符构成，是请求行和请求体之间分隔的标志

3. 请求体

   就是需要传输的数据，对于GET请求而言，信息都在URL中，所以请求体为空；POST的数据都在请求体中



响应报文

1. 响应行

   包含

   1. 状态码

   2. 状态值

   3. HTTP协议版本

   4. 响应头

      响应头部是若干个key-value的键值对，每行一对，用于指示客户端如何处理响应体，告诉浏览器响应的类型、字符编码和字节大小等信息。

2. 空行

   由一个回车符和一个换行符构成，是请求行和请求体之间分隔的标志

3. 响应体

   服务器向客户端返回的数据

### 16.HTTP的长连接

HTTP的短连接和长连接实际上是TCP的长连接和短连接。

对于短连接而言，意味着每次传输数据都要经历创建连接、使用、断开连接的过程；

对于长连接而言，在建立连接后，连接会保持一段时间，在此期间的数据传输都依赖该连接；当长时间没有数据传输时，服务器端会发送嗅探报文，检验连接是否还在保持。当存在多个长连接时，为了腾出空间给新的连接，会踢掉最长时间没有数据通信的长连接。



### 17.HTTPS的加密过程

HTTPS的加密主要使用依赖SSL/TSL协议对HTTP协议传输的明文进行加密，来保证数据安全性。

SSL和TSL协议其实是一类，因为TSL是在SSL 3.0的基础上提出的。

对于TSL协议而言，可以分为TSL握手协议和TSL记录协议。

在整个的加密过程中，通信双方使用了非对称加密和对称加密。

1. 客户端向服务器发送请求，伴随者可用的加密方法等信息；
2. 服务器端向客户端发送选择的加密方法、公钥和签名；
3. 客户端生成一个密钥，并使用公钥加密密钥，然后将加密后的密钥发给服务器；
4. 服务器使用私钥解密加密后的密钥，然后保存。此后所有的数据传输都使用选定的加密方法和密钥进行加解密

但是仅仅这样是不安全的，容易被中间人攻击，所以要引入CA认证。

中间人攻击：

1. 在客户端和服务器端存在一个中间人
2. 中间人劫持了服务器端发送给客户端的公钥和加密方法，然后替换为自己的公钥；
3. 然后截获客户端发给服务器的加密后的密钥，因为使用的是中间人的公钥加密的，所以中间人可以获得密钥，然后使用服务器端的公钥加密一段信息作为对称加密的密钥
4. 这样的话中间人就可以在不被人发觉的情况下查看甚至修改传输的信息

证明了上述的通信过程中存在一个问题：不能验证通信对象的身份。可以使用CA认证解决这个问题。

CA认证：

1. CA是一个公信机构，需要服务器端向其申请，会获得对于的数字证书，其中包含申请机构的相关信息、CA机构的公钥、CA机构对申请机构信息的数字签名
2. 在服务器发给客户端公钥的同时，把数字证书也发送给客户端
3. 客户端可以根据CA的公钥解密数字签名从而验证通信对象的身份
4. 即便存在中间人修改了数字证书的信息，但因为解密后的签名信息对不上也可以发觉中间人的存在

### 18.HTTPS的三次握手和TCP的三次握手的区别

主要区别在于三次握手期间需要传输三个随机数

1. 客户端向服务器端发送连接请求，其中包含着可选用的加密算法、客户端伪随机数a等信息；
2. 服务器根据客户端伪随机数a生成服务器随机数b，然后把服务器随机数b、选择的加密方法等信息发送给客户端
3. 客户端根据随机数b生成随机数c，也就是对称加密的密钥，然后使用服务器的公钥加密之后发送给服务器

使用三个随机数的目的：

1. 主要是为了增加对称加密密钥的随机性
2. 因为使用一个随机数的话出现重复的几率太高了

### 19.浏览器输入地址到显示页面的过程，计算机做了那些规则

1. 浏览器输入URL

2. 解析url地址

3. DNS解析

   主要涉及到以下步骤

   1. 查询浏览器DNS缓存

   2. 查询本机操作系统的DNS缓存

   3. 查询路由器的DNS缓存

   4. 查询ISP服务器的DNS缓存

   5. 查询本地域名服务器

   6. 递归查询

      对url地址递归查询，如www.qq.com就从.com开始查询、然后是qq.com然后是www.qq.com，具体的流程是根域名服务器-->顶级域名服务器-->权限域名服务器-->本地域名服务器

4. 建立TCP连接，主要涉及到三次握手

5. 浏览器向服务器发送HTTP请求，主要涉及到HTTP请求报文的结构、cookie、session、token相关知识

   此时可能出现服务器要求浏览器重定向，即输入http://www.qq.com会被重定向为http://qq.com；

   产生重定向的原因有三个：

   1. 网址别名：

      1. 对于具有多个url的资源，使用重定向可以提高网站的可达性（输入几种都可以到达网站）；
      2. 如果原有网站发送了迁移，可以使用重定向让访问原有地址的请求访问新的地址；
      3. 强制使用HTTPS，将不是HTTPS的请求重定向为HTTPS

   2. 保证已有链接可用

      在进行维护时，将一些修改的url重定向来保证可用性

   3. 对危险操作重定向

      当涉及到比较危险的操作时，如删除操作等，为了避免出现用户刷新导致重复删除的严重情况，可以重定向到临时进度展示页

   浏览器会根据服务器的重定向请求，对重定向地址发送请求

6. 服务器处理请求，并返回HTTP响应，主要涉及到HTTP响应报文的结构

7. 浏览器接收到响应报文，并根据响应头对数据进行处理，然后渲染页面

   可以分为以下步骤：

   1. 生成DOM树：处理HTML、XHTML、SVG等，结合DOM API生成DOM树

   2. 生成CSSOM树：处理css，结合CSSOM API生成CSSOM树

   3. 得到Rendering树：结合DOM树和CSSOM树得到渲染树Rendering Tree

   4. 重绘：主要是通过回写和Rendering Tree，得到每个节点的绝对像素

      回写reflow layout就是根据渲染树Rendering Tree的内容得到每个节点的几何位置（位置、大小等信息）

   5. 展示：将像素的信息交由CPU进行处理，然后使用native GUI的API绘制页面并展示

      需要注意的是JS解析会得到DOM API和CSSOM API，但是JS的解析会阻塞DOM树和CSSOM树的生成，因为JS的内容可以操作DOM和CSSOM，所以一般情况下都是先渲染页面，后执行JS

### 20.HTTP状态码

| 状态码 |                           作用                           |
| :----: | :------------------------------------------------------: |
|  1xx   | 通知信息，表示服务器接收到了请求，需要请求者继续执行操作 |
|  2xx   |              表示成功，操作被成功接收并处理              |
|  3xx   |              重定向，需要进一步操作完成请求              |
|  4xx   |      客户端错误，表示请求包含编译错误或无法完成请求      |
|  5xx   |      服务器端错误，服务器在处理请求的过程中发送错误      |

比较常见的状态码

|          状态码           |                   作用                   |
| :-----------------------: | :--------------------------------------: |
|          200 OK           |                 请求成功                 |
|   301 Moved Permanently   |    重定向，资源等被永久转移到其他URL     |
|     401 Unauthorized      |         请求要求用户进行身份认证         |
|       403 Forbidden       |     服务器接收到了请求，但是禁止访问     |
|       404 Not Found       |         请求的资源（网页）不存在         |
|   408 Request Time-out    | 服务器等待客户端发送的请求时间过长，超时 |
| 500 Internal Server Error |              内部服务器错误              |

### 21.Session和Cookie的区别

|              |                Cookie                |                           Session                            |
| :----------: | :----------------------------------: | :----------------------------------------------------------: |
|   存储位置   |             客户端浏览器             |                           服务器端                           |
|    安全性    |    不安全，可以截获cookie进行攻击    |          安全，因为一般认为SessionID具有不可预测性           |
| 存储数据类型 |       只能存储ASCII编码的数据        |                          基本没限制                          |
|   跨域访问   | 可以实现跨域访问（需要域名后缀相同） |                   只能在单点访问或子域访问                   |
|  有效期不同  |          可以设置为长期有效          | SessionID依赖JSESSIONID的cookie，其默认过期时间为-1，因此只要关闭会话session就会失效 |



## 操作系统

### 1.操作系统的主要功能

1. 进程管理

   在单线程下，为每个进程分配任务，进程管理任务比较简单。

   在多线程下，除了为每个进程分配任务外，还要负责CPU资源的调度、分配和回收

2. 内存管理

   主要是内存的分配和回收。

   进程创建时，为每个进程分配内存空间，进程执行完后，回收空间。同时还要协调内存资源，使用合适的页面置换算法实现页面的换入和换出

3. 设备管理

   根据制定好的设备分配原则完成设备的分配，使主机和设备可以并行运行

4. 文件管理

   主要是负责文件的内存管理，提升文件访问的效率

5. 提供本地接口

   提供访问应用程序和系统的接口，使用户可以通过程序实现系统调用

### 2.软件访问硬件的方式（IO操作的方式）

1. 直接访问

   指数据在内存和CPU或外部设备之间直接交互

   存在的问题：
   	因为内存、CPU、外部设备之间存在速度的差异，所以CPU大部分事件都处在等待状态，造成CPU资源的浪费

2. 中断调用

   只有当外部设备正常完成或异常关闭时才会向CPU发送中断请求。在IO传输的过程中不需要CPU控制

   存在的问题：

   ​	无论资源的大小都需要CPU的介入，虽然比直接访问方式效率要高，但是总体仍旧比较慢

3. DMA直接内存分配

   特点：

   1. 数据的传输单位是数据块
   2. 数据直接从内存到设备或设备到内存
   3. 只有在传输一块或若干块数据块时才需要CPU控制，传输过程由DMA控制，减少了对CPU的占用

   存在的问题：

   1. 虽然效率提高了，但是DMA仅支持少量外围设备

4. 通道传输

   通道是独立于CPU的、专门负责输入输出的控制器，控制内存和设备直接进行数据交换，仅在IO操作开始和结束时才需要CPU控制

   可以支持大量外围设备

### 3.操作系统的结构

微内核：将操作系统分为若干个小的、层级之间更容易定义的内核

目的：内核中出现错误，只会使当前内核中断，而不会使整个操作系统中断

#### 用户态和内核态

目的：将比较危险的操作放在内核中，来确保操作系统的安全性

用户态和内核态存在的区别实际上是对CPU指令的访问权限的不同。

1. 处于内核态的CPU可以直接访问任何数据，包括外围设备的数据，可以从一个进程切换到另一个进程，不会出现CPU抢占的情况
2. 处于用户态的CPU只能受限的访问内存，且不能访问外部设备的数据。无法避免CPU抢占的问题

#### 用户态和内核态切换的过程

1. 从当前进程的描述信息中找到对应内核栈的ss0和esp0（ESP寄存器是栈顶指针寄存器，SS是栈段地址寄存器，通过这两个信息可以在内存中找到对应的内核栈）
2. 在对应的内核栈中保存当前进程的运行环境信息，这样就完成了用户态到内核态的转换
3. 通过调用中断处理程序，开始内核态中的执行
4. 内核态执行完毕后，将结果复制到当前进程的用户栈中相应的寄存器中，重新开始用户态进程的执行



#### 用户态切换为内核态开销大的原因

主要因为过程中存在大量数据的复制和转移操作，开销比较大

1. 保存当前进程的运行环境信息
2. 将用户栈的数据复制到内核栈中
3. 进行检查，因为内核态不信任用户栈的操作
4. 执行内核态
5. 将内核态的执行结果复制到用户态中
6. 恢复用户态的执行现场



#### 用户态切换为内核态的情况

1. 系统调用

   用户程序主动切换到内核态，进行系统调用，向操作系统请求资源来完成工作

2. 中断

   当进程发生中断时，需要切换到内核态，使用内核态中特定的进程处理中断

3. 异常

   当进程发生异常时，需要切换到内核态，使用内核态中特定的进程处理异常



### 4.进程和进程表

#### 进程

就是程序执行的实例

操作系统为每个进程分配资源

#### 进程表

存储着每个进程的状态，以及每个进程打开的资源信息

#### 进程的组成部分

主要由三部分构成

1. 进程控制块PCB，是进程的唯一标识

   包含四个部分

   1. 进程描述信息
   2. 进程控制和管理信息
   3. 资源信息
   4. CPU相关信息

2. 数据段

3. 程序段

#### 进程的状态

1. 创建

2. 就绪

   进程以被创建，且需要的资源也已经准备好了，仅差CPU资源了

3. 运行

   进程获取到CPU资源，开始执行

4. 阻塞

   进程由于某些原因进入阻塞状态，此时CPU即便空闲也不能执行当前进程

5. 结束

   进程正在消失。原因可能是进程正常执行完毕或异常中断

#### 进程控制

主要是控制进程的状态切换，主要涉及进程的创建、进程的阻塞和唤醒、进程的结束

1. 进程的创建

   允许进程创建进程，子进程拥有父进程的所有资源

   创建过程

   1. 在进程表中新增一项，在空闲PCB池中找到一个空闲的PCB分配给新进程
   2. 为新进程分配内存空间，并根据进程管理程序来确定进程加载的程序
   3. 为新进程分配所需的各种资源
   4. 将新进程的PCB初始化
   5. 将新进程的状态设置为就绪状态，并添加到就绪队列中
   
   进程创建的情况
   
   1. 用户登录
   
      在分时系统中，当用户登录时需要创建新进程来处理
   
   2. 作业调度
   
      在批处理系统中，当新作业添加时需要创建新进程来处理
   
   3. 提供服务
   
      当用户向操作系统提出某些请求时，会创建新进程来处理请求
   
   4. 用户要求
   
      用户进程主动创建进程	
   
2. 进程的阻塞和唤醒

   阻塞

   1. 找到需要阻塞的进程的PCB
   2. 保存进程的运行信息，将PCB的状态设置为阻塞态
   3. 将PCB添加到阻塞队列中

   唤醒

   1. 在阻塞队列中找到需要唤醒的进程的PCB
   2. 恢复进程的运行信息，将PCB的状态设置为就绪态
   3. 将PCB添加到就绪队列中

3. 进程的结束

   1. 找到需要结束的进程的PCB
   2. 若仍旧处于运行状态，则立即剥夺其CPU资源，暂停其运行，将其状态设置为结束态
   3. 将其持有的资源还给操作系统或父进程
   4. 若由子进程，则将子进程也结束
   5. 将PCB放入空闲PCB池中

   进程终止的情况

   1. 进程正常结束
   2. 因为异常而中断
   3. 处理器被强行终止

#### 进程的上下文切换

其实就是一个进程切换为另一个进程

1. 将进程A的运行信息保存，然后将PCB设为阻塞态并添加到对应的队列中
2. 将CPU资源分配给进程B，进程B进入运行态
3. 当进程A再次获得CPU资源时，需要根据之前保存的信息恢复运行环境然后再运行

发生上下文切换的场景：

1. 时间片用完
2. 当优先级更高的进程添加进来
3. 进程被阻塞
4. 进程主动阻塞

#### 进程间的通信方式

1. 管道

   发生在内存中，只能完成父子进程或兄弟进程之间的通信

2. 有名管道

   以文件的形式存储在磁盘，发生在内存中，可以实现任意两个进程之间的通信

3. 信号

   以通知的方式，告知通信对象某些事件已发生，但是数据承载量较小

4. 消息队列

   1. 以链表的形式存储消息，使用消息队列标识符进行标记
   2. 可以不以先进先出的顺序进行访问，比如按照类型进程访问
   3. 存储在内存中，只有显式的删除或内核重启
   4. 主要是用来解决信号数据承载量小、管道缓冲区大小受限、只可承接无格式字的问题

5. 信号量

6. 套接字







## `Mysql`

## `Redis`

## `RabbitMQ`

## `Kafka`

## `Spring`相关









## Java 基础 

1.面向对象编程有哪些特征？
 2、JDK 与 JRE 的区别是什么？
 3、Java 有哪几种基本数据类型？
 4、== 和 equals 比较有什么区别？
 5、public,private,protected,默认的区别？
 6、this 和 super 有什么区别？
 7、short s1 = 1; s1 += 1;有错吗？
 8、short s1 = 1; s1 = s1 + 1;有错吗？
 9、float n = 1.8 有错吗？
 10、i++ 和 ++i 的区别？
 11、while 和 do while 有啥区别？
 12、如何跳出 Java 中的循环？
 13、如何跳出 Java 中的多层嵌套循环？
 14、& 和 && 的区别？
 15、2 * 8 最有效率的计算方法是什么？
 16、数组有没有 length 方法？String 呢？
 17、怎么理解值传递和引用传递？
 18、Java 到底是值传递还是引用传递？
 19、一个 ".java" 源文件的类有什么限制？
 20、Java 中的注释有哪些写法？
 21、static 关键字有什么用？
 22、static 变量和普通变量的区别？
 23、static 可以修饰局部变量么？
 24、final 关键字有哪些用法？
 25、final、finally、finalize 有什么区别？
 26、void 和 Void 有什么区别？
 27、为什么 byte 取值范围为 -128～127？
 28、char 类型可以存储中文汉字吗？
 29、重载和重写有什么区别？
 30、构造器可以被重写和重载吗？
 31、main 方法可以被重写和重载吗？
 32、私有方法能被重载或者重写吗？
 33、Java 中的断言（assert）是什么？
 34、Java 异常有哪些分类？
 35、Error 和 Exception 有什么区别？
 36、Java 中常见的异常有哪些？
 37、Java 中常见的运行时异常有哪些？
 38、运行时异常与受检查异常有什么区别？
 39、什么时候会发生空指针异常？
 40、你知道有哪些避免空指针的方法？
 41、throw 和 throws 的区别？
 42、try-catch-finally 中哪个部分可以省略？
 43、try 里面 return，finally还会执行吗？
 44、int 和 Integer 有什么区别？
 45、什么是包装类型？有什么用？
 46、什么是自动装厢、拆厢？
 47、你怎么理解 Java 中的强制类型转换？
 48、你怎么理解 Java 中的自动类型转换？
 49、你怎么理解 Java 中的类型提升？
 50、switch 是否能用在 long 上？
 51、switch 是否能用在 String 上？
 52、switch case 支持哪几种数据类型？
 53、String 属于基础的数据类型吗？
 54、String 类的常用方法都有那些？
 55、String 的底层实现是怎样的？
 56、String 是可变的吗？为什么？
 57、String 类可以被继承吗？
 58、String 真的是不可变的吗？
 59、String 字符串如何进行反转？
 60、String 字符串如何实现编码转换？
 61、String 有没有长度限制？是多少？
 62、为什么不能用 + 拼接字符串？
 63、StringBuffer 和 StringBuilder 的区别？
 64、StringJoiner 有什么用？
 65、Java 所有类的祖先类是哪个？
 66、Object 类有哪些常用的方法？
 67、普通类和抽象类有什么区别？
 68、静态内部类和普通内部类有什么区别？
 69、静态方法可以直接调用非静态方法吗？
 70、静态变量和实例变量有什么区别？
 71、内部类可以访问其外部类的成员吗？
 72、接口和抽象类有什么区别？
 73、接口是否可以继承接口？
 74、接口里面可以写方法实现吗？
 75、抽象类必须要有抽象方法吗？
 76、抽象类能使用 final 修饰吗？
 77、抽象类是否可以继承具体类？
 78、抽象类是否可以实现接口？
 79、怎么查看一个 Java 类的字节码？
 80、Java 中的 UUID 是什么?
 81、Java 类初始化顺序是怎样的？
 82、为什么成员变量命名不建议用 isXXX？
 83、hashCode 有什么用？
 84、hashCode 和 identityHashCode 的区别？
 85、什么是 hash 冲突？
 86、equals 和 hashCode 的区别和联系？
 87、两个对象 equals 相等， hashCode 也相等么？
 88、两个对象 hashCode 相等，equals 也相等么？
 89、为什么重写 equals 就要重写 hashCode 方法？
 90、Java 常用的元注解有哪些？
 91、Java 泛型中的 T、R、K、V、E 分别指什么？
 92、Java 金额计算怎么避免精通丢失？
 93、Java 语法糖是什么意思？
 94、transient 关键字有什么用？
 95、如何实现对象克隆？
 96、对象克隆浅拷贝和深拷贝的区别？
 97、Java 反射机制有什么用？
 98、Java 反射机制的优缺点？
 99、Java 反射机制 Class 类有哪些常用方法？
 100、Java 反射可以访问私有方法吗？
 101、Java 反射可以访问私有变量吗？
 102、Class.forName 和 ClassLoader 的区别？
 103、什么是宏变量和宏替换？
 104、什么是逃逸分析？
 105、什么是伪共享？有什么解决方案？
 106、Java 有没有 goto 关键字？
 107、Java 中有没有指针的概念？
 108、Java 中的 classpath 环境变量作用？
 109、Math.round(1.5) 等于多少？
 110、Math.round(-1.5) 等于多少？
 111、Java 8 都新增了哪些新特性？
 112、Java 8 中的 Lambda 表达式有啥用？
 113、Java 8 中的 Optional 类有什么用？
 114、Java 8 中的 Stream 有啥用？
 115、Java 8 中的@Repeatable 注解有什么用？
 116、Java 8 中的方法引用是指什么？
 117、Java 8 中的函数式编程怎么用？
 118、怎么创建一个 Stream 流？
 119、Oracle JDK 和 OpenJDK 有啥区别？ 

##  Java 集合 

 1、说说常见的集合有哪些？
 2、哪些集合类可对元素的随机访问？
 3、Comparable 和 Comparator 接口的区别？
 4、Collection 和 Collections 的区别？
 5、Enumeration 和 Iterator 接口的区别？
 6、集合使用泛型有什么优点？
 7、List、Set、Map 之间的区别是什么？
 8、为什么 Map 接口不继承 Collection 接口？
 9、常用的线程安全的 Map 有哪些？
 10、HashMap 与 Hashtable 的区别？
 11、HashMap 和 TreeMap 怎么选？
 12、HashMap 的数据结构是什么？
 13、HashMap 在 JDK 8 中有哪些改变？
 14、HashMap 的 put 方法逻辑？
 15、HashMap 的 get 方法逻辑？
 16、HashMap 是线程安全的吗？
 17、HashMap 是怎么解决 hash 冲突的？
 18、HashMap 是怎么扩容的？
 19、HashMap 如何实现同步?
 20、HashMap 中的负载因子是什么？
 21、Hashtable 为什么不叫 HashTable？
 22、ConcurrentHashMap 的数据结构？
 23、ArrayList 是线程安全的么？
 24、常用的线程安全的 List 集合有哪些？
 25、循环删除 List 集合可能会发生什么异常？
 26、ArrayList 和 LinkedList 的区别？
 27、ArrayList 和 Vector 的区别？
 28、什么是 CopyOnWriteArrayList？
 29、什么是 fail-safe？
 30、什么是 fail-fast？
 31、fail-fast 与 fail-safe 有什么区别？
 32、HashSet 的底层实现原理是什么？
 33、怎么确保一个集合不能被修改？ 

##  JVM 

 1、Java 为什么能一次编写，处处运行？
 2、JVM 是什么？
 3、HotSpot 是什么？
 4、JVM 内存区域分类哪些？
 5、堆和栈区别是什么？
 6、JVM 哪块内存区别不会发生内存溢出？
 7、什么情况下会发生栈内存溢出？
 8、对象都是在堆上分配的吗？
 9、你怎么理解强、软、弱、虚引用？
 10、常用的 JVM 参数有哪些？
 11、Java 8 中的内存结构有什么变化？
 12、Java 8 中的永久代为什么被移除了？
 13、什么是类加载器？
 14、类加载器的分类及作用？
 15、什么是双亲委派模型？
 16、为什么要打破双亲委派模型？
 17、可以自定义一个 java.lang.String 吗？
 18、什么是 JVM 内存模型？
 19、JVM 内存模型和 JVM 内存结构的区别？
 20、什么是指令重排序？
 21、内存屏障是什么？
 22、什么是 Happens-Before 原则？
 23、GC 是什么？为什么需要 GC？
 24、什么是 MinorGC 和 FullGC？
 25、一次完整的 GC 流程是怎样的？
 26、JVM 如何判断一个对象可被回收？
 27、常用的垃圾收集器有哪些？
 28、常用的垃圾回收算法有哪些？
 29、什么是内存泄漏？
 30、为什么会发生内存泄漏？
 31、如何防止内存泄漏？
 32、什么是直接内存？
 33、直接内存有什么用？
 34、怎样访问直接内存？
 35、常用的 JVM 调优命令有哪些？
 36、常用的 JVM 问题定位工具有哪些？
 37、常用的主流 JVM 虚拟机都有哪些？ 

##  多线程（并发编程） 

 1、进程和线程的区别？
 2、什么是原子性、可见性、有序性？
 3、为什么要使用多线程？
 4、创建线程有哪几种方式？
 5、什么是守护线程？
 6、线程的状态有哪几种？怎么流转的？
 7、线程的优先级有什么用？
 8、我们常说的 JUC 是指什么？
 9、i++ 是线程安全的吗？
 10、join 方法有什么用？什么原理？
 11、如何让一个线程休眠？
 12、启动一个线程是用 start 还是 run 方法？
 13、start 和 run 方法有什么区别？
 14、sleep 和 wait 方法有什么区别？
 15、Thread.yield 方法有什么用？
 16、yield 和 sleep 有什么区别？
 17、怎么理解 Java 中的线程中断？
 18、你怎么理解多线程分组？
 19、你怎么理解 wait、notify、notifyAll？
 20、同步和异步的区别？
 21、什么是死锁？
 22、怎么避免死锁？
 23、什么是活锁？
 24、什么是无锁？
 25、什么是线程饥饿？
 26、什么是 CAS？
 27、阻塞和非阻塞的区别？
 28、并发和并行的区别？
 29、为什么不推荐使用 stop 停止线程？
 30、如何优雅地终止一个线程？
 31、Synchronized 同步锁有哪几种用法？
 32、什么是重入锁（ReentrantLock）？
 33、Synchronized 与 ReentrantLock 的区别？
 34、synchronized 锁的是什么?
 35、什么是读写锁？
 36、公平锁和非公平锁的区别？
 37、有哪些锁优化的方式？
 38、什么是偏向锁？
 39、什么是轻量级锁？
 40、什么是自旋锁？
 41、什么是锁消除？
 42、什么是锁粗化？
 43、什么是重量级锁？
 44、什么是线程池？
 45、使用线程池有什么好处？
 46、创建一个线程池有哪些核心参数？
 47、线程池的工作流程是怎样的？
 48、Java 里面有哪些内置的线程池？
 49、为什么阿里不让用 Executors 创建线程池？
 50、线程池的拒绝策略有哪几种？
 51、如何提交一个线程到线程池？
 52、线程池 submit 和 execute 有什么区别？
 53、如何查看线程池的运行状态？
 54、如何设置线程池的大小？
 55、如何关闭线程池？
 56、AQS 是什么？
 57、AQS 的底层原理是什么？
 58、Java 中的 Fork Join 框架有什么用？
 59、ThreadLocal 有什么用？
 60、ThreadLocal 有什么副作用？
 61、volatile 关键字有什么用？
 62、volatile 有哪些应用场景？
 63、CyclicBarrier 有什么用？
 64、CountDownLatch 有什么用？
 65、CountDownLatch 与 CyclicBarrier 的区别？
 66、Semaphore 有什么用？
 67、Exchanger 有什么用？
 68、LockSupport 有什么用？
 69、Java 中原子操作的类有哪些？
 70、什么是 ABA 问题？怎么解决？
 71、Java 并发容器，你知道几个？
 72、什么是阻塞队列？
 73、阻塞队列有哪些常用的应用场景？
 74、Java 中的阻塞的队列有哪些？
 75、什么是幂等性？ 

##  IO（网络编程） 

 1、什么是 IO？
 2、常用的 IO 类有哪些？
 3、你怎么理解 IO、BIO、NIO、AIO？
 4、什么是比特(Bit)、字节(Byte)、字符(Char)？
 5、Java 有哪几种类型的流？
 6、字节流和字符流的区别？
 7、Java 序列化是什么？
 8、怎么序列化一个对象？
 9、Java 有哪两种序列化方式？
 10、怎么控制类中的某些变量不被序列化？
 11、静态变量能不能被序列化？
 12、OSI 的七层模型都有哪些？
 13、tcp 和 udp 协议的区别？
 14、tcp 为什么要三次握手，两次不行吗？ 

##  Web 编程 

 1、http 和 https 的区别？
 2、get 和 post 的区别？
 3、forward 和 redirect 的区别？
 4、Servlet 是什么？
 5、Servlet 的生命周期是怎样的？
 6、Servlet 有哪些核心的方法？
 7、Servlet 是线程安全的么？
 8、Servlet 支持异步处理吗？
 9、Servlet 是单例还是多例？
 10、Servlet 和 JSP 有什么区别和联系？
 11、JSP 是什么？
 12、JSP 有哪些内置对象？
 13、JSP 有哪些基本动作？
 14、JSP 有哪几种作用域？
 15、JSP 有哪些常用指令？
 16、如何实现隐藏的表单域？
 17、AJAX 应用和传统 Web 应用有什么不同？
 18、怎么优化 Web 前端的性能？
 19、什么是 MVC？分别代表什么？
 20、拦截器和过滤器的区别？
 21、Cookie 和 Session 的区别？
 22、什么是跨域？有哪些解决方案？ 

## Spring 

 1、Spring 框架是什么？
 2、Spring 常用的注解有哪些？
 3、Spring 框架的好处有哪些？
 4、Spring 由哪些主要模块组成？
 5、Spring IOC 容器是什么？
 6、Spring IOC 的好处有哪些？
 7、BeanFactory 和 ApplicationContext 的区别？
 8、Spring 依赖注入是什么？
 9、Spring 依赖注入有哪几种方式？
 10、Spring bean 支持哪几种作用域？
 11、Spring bean 生命周期是怎样的？
 12、Spring bean 为什么默认为单例？
 13、Spring bean 是线程安全的吗？
 14、Spring 这几个注解的区别？
 15、Spring @Autowired 注解有什么用？
 16、Spring @Required 注解有什么用？
 17、Spring @Qualifier 注解有什么用？
 18、Spring 怎么注入 Java 集合类型？
 19、Spring 装配是指什么？
 20、Spring 自动装配有哪些方式？
 21、Spring 自动装配有什么局限性？
 22、Spring AOP 是什么？
 23、Spring AOP 有什么作用？
 24、Spring AOP 有哪些实现方式？
 25、Spring AOP 和 AspectJ AOP 的区别？
 26、Spring 支持哪些事务管理类型？
 27、Spring 框架用到了哪些设计模式？
 28、Spring MVC 框架有什么用？
 29、Spring MVC DispatcherServlet 的工作流程？
 30、Spring MVC 常用的注解有哪些？
 31、Spring MVC @RequestMapping() 有啥用？ 

##  Spring Boot 

 1、Spring Boot 是什么？
 2、Spring Boot 有哪些优缺点？
 3、Spring Boot 框架的核心思想是什么？
 4、Spring Boot 有哪些核心模块？
 5、Spring Boot 的核心配置文件有哪些？
 6、Spring Boot 的配置文件有哪几种格式？
 7、Spring Boot 的核心注解是哪个？
 8、SpringBootApplication 注解包含哪几个注解？
 9、Spring Boot 最核心的注解有哪些？
 10、Spring Boot 怎么根据指定条件注册 bean？
 11、Spring Boot 有哪些条件注解？
 12、Spring Boot 有哪两种方式集成？
 13、Spring Boot 需要独立的容器运行吗？
 14、Spring Boot 中的默认内嵌容器是？
 15、Spring Boot 中的内嵌容器可以替换成别的么？
 16、Spring Boot 自动配置原理是什么？
 17、Spring Boot 开启自动配置的注解是？
 18、Spring Boot 自动配置的类在哪注册？
 19、Spring Boot 自动配置报告怎么查看？
 20、Spring Boot 怎么排除某些自动配置？
 21、Spring Boot 怎么开启和关闭自动配置？
 22、Spring Boot 的目录结构是怎样的？
 23、Spring Boot 中的 Starters 是什么？
 24、Spring Boot Starters 有什么命名规范？
 25、Spring Boot Starters 官方有哪些分类？
 26、Spring Boot 怎么自定义一个 Starter？
 27、Spring Boot 有哪几种运行方式？
 28、Spring Boot 支持哪些应用打包方式？
 29、Spring Boot 应用怎么 Debug 调试？
 30、Spring Boot 可以配置随机端口吗？
 31、Spring Boot 怎么打一个可执行 Jar 包？
 32、Spring Boot 支持 https 配置吗？
 33、Spring Boot 怎么注册 Servlet？
 34、Spring Boot Runner 是什么？
 35、Spring Boot 支持哪些模板引擎？
 36、Spring Boot 支持 Velocity 模板引擎吗？
 37、Spring Boot 怎么做单元测试？
 38、Spring Boot 支持哪些日志框架？
 39、Spring Boot 有哪几种热部署方式？
 40、Spring Boot 配置加载顺序是怎样的？
 41、Spring Boot 如何定义不同环境配置？
 42、Spring Boot 怎么兼容老 Spring 项目？
 43、Spring Boot 应用有哪些保护手法？
 44、Spring Boot 怎么注册事件监听器？
 45、Spring Boot 应用如何监控和健康检查？
 46、Spring Boot 怎么解决跨域问题？
 47、Spring Boot 2.X 有什么新特性？
 48、Spring Boot 怎么定制启动图案？
 49、Spring Boot 怎么关闭启动图案？
 50、Spring Boot 的默认编码是？
 51、Spring Boot 怎么指定编码格式？
 52、Spring Boot 应用如何优雅关闭？ 

##  Spring Cloud 

 1、Spring Cloud 是什么？
 2、Spring Cloud 和 Spring Boot 的关系？
 3、Spring Cloud 有哪些重要的组件？
 4、Spring Cloud 和 Dubbo 的区别？
 5、Spring Cloud 版本号怎么理解？
 6、Spring Cloud Eureka 保护机制是什么？
 7、Spring Cloud 注册中心有哪些实现方案？
 8、Spring Cloud 配置中心有哪些实现方案？
 9、Spring Cloud 如何保证微服务调用安全性？
 10、Spring Cloud 中的 Ribbon 是什么？
 11、Spring Cloud 中的 Feign 是什么？
 12、Spring Cloud Feign 和 ribbon 的区别？
 13、Spring Cloud Gateway VS Zuul 怎么选？
 14、Spring Cloud for Alibaba 是什么？ 

##  Dubbo 

 1、Dubbo 是什么框架？
 2、为什么要用 Dubbo？
 3、Dubbo 里面有哪几种节点角***r /> 4、Dubbo 停止维护了吗？
 5、Dubbo 必须依赖的包有哪些？
 6、Dubbo 支持哪些注册中心？推荐哪种？
 7、Dubbo 内置了哪几种服务容器？
 8、Dubbo 需要 Web 容器吗？
 9、Dubbo 的服务注册和发现流程？
 10、Dubbo 服务暴露的过程？
 11、Dubbo 有哪几种配置方式？
 12、Dubbo 核心的配置有哪些？
 13、Provider 可以配置 Consumer 哪些属性？
 14、Dubbo 启动时依赖的服务不可用会怎样？
 15、Dubbo 都支持什么协议，推荐用哪种？
 16、Dubbo 支持什么通信框架？默认哪种？
 17、Dubbo 支持的序列化框架有哪些？
 18、Dubbo 有哪些集群容错方案，默认哪种？
 19、Dubbo 有哪些负载均衡策略，默认哪种？
 20、有多个同名服务时，如果连接指定的服务？
 21、Dubbo 支持服务多协议吗？
 22、Dubbo 服务上线怎么兼容旧版本？
 23、Dubbo 一个服务接口有多种实现怎么区分？
 24、Dubbo 可以对结果进行缓存吗？
 25、Dubbo 服务之间的调用是阻塞的吗？
 26、Dubbo 支持分布式事务吗？
 27、Dubbo telnet 命令能做什么？
 28、Dubbo 支持服务降级吗？
 29、Dubbo 如何优雅停机？
 30、Dubbo 服务提供者失效自动下线是什么原理？
 31、Dubbo 服务调用链过长如何解决？
 32、Duboo 服务读写容错策略怎么做？
 33、Dubbo 的管理控制台能做什么？
 34、Dubbo 能集成 Spring Boot 吗？
 35、Dubbo 使用过程中都遇到了些什么问题？
 36、Dubbo 的源码你有读过吗？
 37、Dubbo 和 Spring Cloud 哪个好？
 38、Dubbo 你们的推荐用法有哪些？
 39、你怎么理解 Dubbo SPI？
 40、Dubbo 之外，你还了解别的 RPC 框架吗？
 41、Dubbox 是什么？和 Dubbo 有啥区别？ 

##  MySQL（数据库） 

 1、主键、外键有什么区别？
 2、怎么理解三范式和反范式？
 3、范式和反范式的优缺点？
 4、什么是事务？
 5、事务有哪几个特性？
 6、什么是脏读、幻读、不可重复读？
 7、MySQL 有哪些事务隔离级别？
 8、MySQL 默认的事务隔离级别是？
 9、什么是索引？
 10、索引有什么用？
 11、索引为什么能提高查询效率？
 12、索引的设计有哪些原则？
 13、什么情况下应不建或少建索引？
 14、MySQL 索引的种类有哪些？
 15、MySQL 索引最左匹配原则怎么理解？
 16、MySQL 数据库引擎怎么选择？
 17、MySQL 默认数据库引擎是什么？
 18、MySQL 引擎 MyISAM 和 InnoDB 的区别？
 19、char 和 varchar 的区别？
 20、MySQL 的 drop、delete、truncate区别？
 21、MySQL 怎么实现分页查询？
 22、MySQL 的高可用方案有哪些？
 23、如何分析一条 SQL 语句的执行计划和性能？
 24、MySQL 查询优化有哪些方法？
 25、MySQL 为什么不建议默认 null 值？
 26、MySQL 为什么尽量选择最小数据类型？
 27、怎么理解数据库中的乐观锁和悲观锁？
 28、MySQL 中的 MVCC 是指什么？
 29、MySQL InnoDB 的 MVCC 实现机制？
 30、MySQL 中的 MVCC 支持哪些事务隔离级别？
 31、MySQL 支持哪三种级别的锁？
 32、MySQL InnoDB 支持什么锁？
 33、MySQL 中的表锁有哪些？
 34、MySQL 中的行锁有哪些？
 35、MySQL 中的意向锁有什么用？
 36、MySQL 中的意向锁的分类？
 37、MySQL 中的意向锁是表锁还是行锁？
 38、MySQL 中的自增锁有什么用？
 39、MySQL 行锁是锁的是什么？
 40、MySQL 行锁实现的几种算法？
 41、MySQL 什么情况会发生死锁？
 42、MySQL 死锁怎么排查？
 43、MySQL 如何解决死锁？
 44、MySQL 如何避免死锁？
 45、MySQL 和 MariaDB 的区别？
 46、MySQL 日志 undo 和 redo 的区别？
 47、什么是表分区？
 48、表分区有什么好处？
 49、表分区与分表的区别？
 50、MySQL 支持的分区类型有哪些？
 51、MySQL 分区表有哪些限制因素？
 52、MySQL 为什么要分库分表？
 53、MySQL 分库分表怎么做？
 54、MySQL 分库分表工具有哪些？
 55、MySQL 分库分表会产生哪些问题？
 56、MySQL 批量插入，如何不插入重复数据？ 

##  Redis（缓存） 

 1、Redis 是什么？
 2、Redis 有哪些应用场景？
 3、Redis 有什么优势？
 4、Redis 为什么这么快？
 5、Redis 主要消耗什么物理资源？
 6、Redis 到底是单线程还是多线程？
 7、Redis 和 Memcache 有什么区别？
 8、Redis 支持哪些数据类型？
 9、Redis 默认支持多少个数据库？怎么修改？
 10、Redis 最大 key 大小？
 11、Redis String 值最大存储多少？
 12、Redis 事务有什么用？
 13、Redis 事务相关的命令有哪几个？
 14、Redis 持久化有什么用？
 15、Redis 有哪几种持久化方式？
 16、Redis 持久化方式如何选择？
 17、Redis 内存满了怎么办？
 18、Redis 有哪些淘汰策略？
 19、Redis 如何提高多核 CPU 利用率？
 20、Redis 如何实现大量数据插入？
 21、Redis 的回收进程如何工作的？
 22、Redis 中的管道有什么用？
 23、Redis 有哪些高可用方案？
 24、Redis 集群如何选择数据库？
 25、Redis 哈希槽怎么理解？
 26、Redis 支持的 Java 客户端有哪些？
 27、Redisson 是什么框架？
 28、Redis 和 Redisson 有什么关系？
 29、Jedis 和 Redisson 对比有什么优缺点？
 30、Redis 为什么不提供 Windows 版本？
 31、Redis 如何设置密码访问？
 32、Redis 如何分析慢查询操作？
 33、什么是缓存预热和热备？
 34、什么是缓存雪崩，如何解决？
 35、什么是缓存穿透，如何解决？
 36、什么是缓存击穿，如何解决？
 37、什么是缓存抖动，如何解决？
 38、什么是缓存无底洞现象，如何解决？
 39、Redis 和数据库双写一致性问题如何解决？
 40、Redis 有哪些危险命令？如何防范？
 41、Redis 如何统计独立用户访问量？ 

##  Zookeeper 

 1、ZooKeeper 是什么？
 2、ZooKeeper 有哪些特性？
 3、ZooKeeper 有哪些应用场景？
 4、Zookeeper 支持哪些数据节点类型？
 5、Zookeeper 常用的命令有哪些？
 6、Zookeeper 服务器有哪几种角***r /> 7、Zookeeper 服务器有哪几种工作状态？
 8、Zookeeper 支持哪些 Java 客户端？
 9、ZooKeeper 有几种部署模式？
 10、Zookeeper 集群最少要几台机器，为什么?
 11、Zookeeper 集群支持动态添加机器吗？
 12、ZooKeeper 是如何实现分布式事务的？
 13、ZooKeeper 是如何实现分布式锁的？
 14、Zookeeper 中的文件系统怎么理解？
 15、Zookeeper 和 Chubby 的区别？
 16、怎么理解 ZAB 协议？
 17、ZAB 和 Paxos 算法的联系与区别？ 

##  分布式 

 1、什么是 SOA？
 2、SOA 和微服务架构有什么区别？
 3、什么是 CAP 原则？
 4、什么是 BASE 原则？
 5、什么是 RMI？
 6、什么是 RPC？
 7、RMI 和 RPC 有什么区别？
 8、分布式系统下会遇到哪些问题？
 9、分布式 Session 共享怎么实现？
 10、分布式唯一 ID 怎么实现？
 11、什么是分布式事务？
 12、分布式事务的解决方案有哪些？
 13、什么是微服务？
 14、微服务架构有什么优势？
 15、微服务架构有什么缺点？
 16、什么是服务治理？
 17、什么是服务降级？
 18、服务降级的方案有哪些？
 19、什么是服务雪崩？
 20、什么是服务熔断？ 

##  MyBatis 

 1、MyBatis 是什么框架？
 2、MyBatis 和 ORM 的区别？
 3、MyBatis 为什么是半自动 ORM 映射？
 4、MyBatis 框架的应用场景？
 5、MyBatis 有哪些优点？
 6、MyBatis 有哪些缺点？
 7、MyBatis 和 Hibernate 的区别？
 8、MyBatis 和 JPA 的区别？
 9、MyBatis 有哪几种 SQL 编写形式？
 10、MyBatis 支持哪些传参数的方法？
 11、MyBatis 的 $ 和 # 传参的区别？
 12、MyBatis 可以映射到枚举类吗？
 13、MyBatis 怎么封装动态 SQL？
 14、Mybatis trim 标签有什么用？
 15、MyBatis 怎么实现分页？
 16、MyBatis 流式查询有什么用？
 17、MyBatis 模糊查询 like 语句该怎么写？
 18、MyBatis 配置文件中的 SQL id 是否能重复？
 19、MyBatis 如何防止 SQL 注入？
 20、MyBatis 如何获取自动生成的主键id？
 21、MyBatis 使用了哪些设计模式？
 22、MyBatis 中的缓存机制有啥用？
 23、MyBatis 一级缓存和二级缓存的区别？
 24、MyBatis-Plus 是什么框架？ 

##  消息队列 

 1、消息队列有什么用？
 2、消息队列有哪些应用场景？
 3、消息队列有什么优缺点？
 4、消息队列怎么选型？
 5、有了多线程，为什么还要消息队列？
 6、消息队列和多线程应该怎么选择呢？
 7、使用消息队列会遇到哪些问题？
 8、消息队列如何处理消息重复消费问题？
 9、消息队列为什么会产生消息丢失？
 10、消息队列如何解决消息丢失问题？
 11、消息队列如何保证消息顺序消费？
 12、消息延迟推送有哪些应用场景？
 13、什么是拉模式和推模式？
 14、什么是消息持久化？
 15、消息持久化有什么缺点？
 16、什么是 JMS？
 17、什么是 RabbitMQ？
 18、RabbitMQ 有哪些优点？
 19、RabbitMQ 有哪些重要的组件？
 20、RabbitMQ 有哪些重要的角***r /> 21、RabbitMQ 交换器类型有哪些？
 22、RabbitMQ 消息基于什么传输？
 23、RabbitMQ 怎么避免消息丢失？
 24、RabbitMQ 怎么保证消息的稳定性？
 25、RabbitMQ 支持事务消息吗？
 26、RabbitMQ 事务消息在什么情况下无效？
 27、RabbitMQ 接收到消息之后必须消费吗？
 28、RabbitMQ 如何确保每个消息能被消费？
 29、RabbitMQ 消息持久化的条件？
 30、RabbitMQ 中的死信队列是什么？
 31、RabbitMQ 队列中的消息是否有数量限制?
 32、RabbitMQ 怎么实现消息延迟推送？ 

##  Linux 

 1、Linux 是什么？
 2、Linux 和 Unix 的区别？
 3、Linux 系统有哪些优势？
 4、Linux 怎么查看内核版本？
 5、RedHat、CentOS、Ubuntu 有什么区别？
 6、Linux 和 Windows 正反斜杠的区别？
 7、Linux 环境变量配置有哪几种方式？
 8、Linux 安装软件有哪几种方式？
 9、Linux 普通用户怎么以管理员身份执行指令？
 10、Linux 的 root 和 home 目录有什么不同？
 11、Linux 系统 root 和普通用户的区别？
 12、Linux 怎么区分 root 和普通用户？
 13、Linux 怎么切换用户？
 14、Linux 中的 bash 是什么？
 15、Linux 中的 Shell 是什么？
 16、Linux 怎么显示目录下的文件？
 17、Linux 中 ll 和 ls 命令的区别？
 18、Linux 怎么创建文件？
 19、Linux 怎么创建目录？
 20、Linux 怎么切换目录？
 21、Linux 怎么切换到上 N 级目录？
 22、Linux 怎么切换到之前所在的目录？
 23、Linux 怎么切换到当前用户主目录？
 24、Linux 怎么查看当前目录所在路径？
 25、Linux 下的权限有哪几种？
 26、Linux 文件调用权限分为哪 3 级？
 27、Linux 怎么修改文件权限？
 28、Linux 怎么修改文件所有者和所属组？
 29、Linux 怎么查看磁盘的使用情况？
 30、Linux 怎么查看内存的使用情况？
 31、Linux 怎么查看资源消耗最多的进程？
 32、Linux 怎么看端口被哪个进程占用？
 33、Linux 怎么查找某个进程？
 34、Linux 怎么结束某个进程？
 35、Linux 怎么清屏？
 36、Linux 控制台怎么设置超时自动注销？
 37、Linux vim 和 vi 命令的区别？
 38、Linux vim 命令怎么使用？
 39、Linux 软链接和硬链接区别？
 40、Linux 怎么创建软、硬链接？
 41、Linux 中的零拷贝是指什么？
 42、Linux 下 select,poll,epoll 的区别？



# JAVA基础 

1.  JAVA中的几种基本数据类型是什么，各自占用多少字节。 
2.  String类能被继承吗，为什么。 
3.  String，Stringbuffer，StringBuilder的区别。 
4.  ArrayList和LinkedList有什么区别。 
5.  讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。 
6.  用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。 
7.  JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。 
8.  有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。 
9.  抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。 
10.  继承和聚合的区别在哪。 
11.  IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型。 
12.  反射的原理，反射创建类实例的三种方式是什么。 
13.  反射中，Class.forName和ClassLoader区别 。 
14.  描述动态代理的几种实现方式，分别说出相应的优缺点。 
15.  动态代理与cglib实现的区别。 
16.  为什么CGlib方式可以对接口实现代理。 
17.  final的用途。 
18.  写出三种单例模式实现 。 
19.  如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。 
20.  请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。 
21.  深拷贝和浅拷贝区别。 
22.  数组和链表数据结构描述，各自的时间复杂度。 
23.  error和exception的区别，CheckedException，RuntimeException的区别。 
24.  请列出5个运行时异常。 
25.  在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么。 
26.  说一说你对java.lang.Object对象中hashCode和equals方法的理解。在什么场景下需 
27.  要重新实现这两个方法。 
28.  在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。 
29.  这样的a.hashcode() 有什么用，与a.equals(b)有什么关系。 
30.  有没有可能2个不相等的对象有相同的hashcode。 
31.  Java中的HashSet内部是如何工作的。 
32.  什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。 
33.  java8的新特性。 

#  JVM知识 

1.  什么情况下会发生栈内存溢出。 
2.  JVM的内存结构，Eden和Survivor比例。 
3.  JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。 
4.  JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。 
5.  你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。 
6.  垃圾回收算法的实现原理。 
7.  当出现了内存溢出，你怎么排错。 
8.  JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作 
9.  内存等。 
10.  简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。 
11.  讲讲JAVA的反射机制。 
12.  你们线上应用的JVM参数有哪些。 
13.  g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择。 
14.  怎么打出线程栈信息。 
15.  请解释如下jvm参数的含义： 
16.  -server -Xms512m -Xmx512m -Xss1024K 
17.  -XX:PermSize=256m -XX:MaxPermSize=512m - 
18.  XX:MaxTenuringThreshold=20XX:CMSInitiatingOccupancyFraction=80 - 
20.  XX:+UseCMSInitiatingOccupancyOnly。 

#  开源框架知识 

1.  简单讲讲tomcat结构，以及其类加载器流程，线程模型等。 
2.  tomcat如何调优，涉及哪些参数 。 
3.  讲讲Spring加载流程。 
4.  Spring AOP的实现原理。 
5.  讲讲Spring事务的传播属性。 
6.  Spring如何管理事务的。 
7.  Spring怎么配置事务（具体说出一些关键的xml 元素）。 
8.  说说你对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原 
9.  理，说说aop中的几个术语，它们是怎么相互工作的。 
10.  Springmvc 中DispatcherServlet初始化过程。 
11.  netty的线程模型，netty如何基于reactor模型上实现的。 
12.  为什么选择netty。 
13.  什么是TCP粘包，拆包。解决方式是什么。 
14.  netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决。 
15.  netty的心跳处理在弱网下怎么办。 
16.  netty的通讯协议是什么样的。 
17.  springmvc用到的注解，作用是什么，原理。 
18.  springboot启动机制。 
19.  点击这里有一套答案版的Spring试题。 

#  操作系统 

1.  Linux系统下你关注过哪些内核参数，说说你知道的。 
2.  Linux下IO模型有几种，各自的含义是什么。 
3.  epoll和poll有什么区别。 
4.  平时用到哪些Linux命令。 
5.  用一行命令查看文件的最后五行。 
6.  用一行命令输出正在运行的java进程。 
7.  介绍下你理解的操作系统中线程切换过程。 
8.  进程和线程的区别。 
9.  top 命令之后有哪些内容，有什么作用。 
10.  线上CPU爆高，请问你如何找到问题所在。 

#  多线程 

1.  多线程的几种实现方式，什么是线程安全。 
2.  volatile的原理，作用，能代替锁么。 
3.  画一个线程的生命周期状态图。 
4.  sleep和wait的区别。 
5.  sleep和sleep(0)的区别。 
6.  Lock与Synchronized的区别 。 
7.  synchronized的原理是什么，一般用在什么地方(比如加在静态方法和非静态方法的区别，静 
8.  态方法和非静态方法同时执行的时候会有影响吗)，解释以下名词：重排序，自旋锁，偏向锁，轻 
9.  量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁。 
10.  用过哪些原子类，他们的原理是什么。 
11.  JUC下研究过哪些并发工具，讲讲原理。 
12.  用过线程池吗，如果用过，请说明原理，并说说newCache和newFixed有什么区别，构造函 
13.  数的各个参数的含义是什么，比如coreSize，maxsize等。 
14.  线程池的关闭方式有几种，各自的区别是什么。 
15.  假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同 
16.  时调用它，如何做到。 
17.  spring的controller是单例还是多例，怎么保证并发的安全。 
18.  用三个线程按顺序循环打印abc三个字母，比如abcabcabc。 
19.  ThreadLocal用过么，用途是什么，原理是什么，用的时候要注意什么。 
20.  如果让你实现一个并发安全的链表，你会怎么做。 
21.  有哪些无锁数据结构，他们实现的原理是什么。 
22.  讲讲java同步机制的wait和notify。 
23.  CAS机制是什么，如何解决ABA问题。 
24.  多线程如果线程挂住了怎么办。 
25.  countdowlatch和cyclicbarrier的内部原理和用法，以及相互之间的差别(比如 
26.  countdownlatch的await方法和是怎么实现的)。 
27.  对AbstractQueuedSynchronizer了解多少，讲讲加锁和解锁的流程，独占锁和公平所 
28.  加锁有什么不同。 
29.  使用synchronized修饰静态方法和非静态方法有什么区别。 
30.  简述ConcurrentLinkedQueue和LinkedBlockingQueue的用处和不同之处。 
31.  导致线程死锁的原因？怎么解除线程死锁。 
32.  非常多个线程（可能是不同机器），相互之间需要等待协调，才能完成某种工作，问怎么设计这种协调方案。 
33.  用过读写锁吗，原理是什么，一般在什么场景下用。 
34.  开启多个线程，如果保证顺序执行，有哪几种实现方式，或者如何保证多个线程都执行完 
35.  再拿到结果。 
36.  延迟队列的实现方式，delayQueue和时间轮算法的异同。 
37.  点击这里有一套答案版的多线程试题。 

#  TCP与HTTP 

1.  http1.0和http1.1有什么区别。 
2.  TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么。 
3.  TIME_WAIT和CLOSE_WAIT的区别。 
4.  说说你知道的几种HTTP响应码，比如200, 302, 404。 
5.  当你用浏览器打开一个链接（如：http://www.javastack.cn）的时候，计算机做了哪些工作步骤。 
6.  TCP/IP如何保证可靠性，说说TCP头的结构。 
7.  如何避免浏览器缓存。 
8.  如何理解HTTP协议的无状态性。 
9.  简述Http请求get和post的区别以及数据包格式。 
10.  HTTP有哪些method 
11.  简述HTTP请求的报文格式。 
12.  HTTP的长连接是什么意思。 
13.  HTTPS的加密方式是什么，讲讲整个加密解密流程。 
14.  Http和https的三次握手有什么区别。 
15.  什么是分块传送。 
16.  Session和cookie的区别。 
17.  点击这里有一套答案版的试题。 

#  架构设计与分布式 

1.  用java自己实现一个LRU。 
2.  分布式集群下如何做到唯一序列号。 
3.  设计一个秒杀系统，30分钟没付款就自动关闭交易。 
4.  如何使用redis和zookeeper实现分布式锁？有什么区别优缺点，会有什么问题，分别适用什么 
5.  场景。（延伸：如果知道redlock，讲讲他的算法实现，争议在哪里） 
6.  如果有人恶意创建非法连接，怎么解决。 
7.  分布式事务的原理，优缺点，如何使用分布式事务，2pc 3pc 的区别，解决了哪些问题，还有 
8.  哪些问题没解决，如何解决，你自己项目里涉及到分布式事务是怎么处理的。 
9.  什么是一致性hash。 
10.  什么是restful，讲讲你理解的restful。 
11.  如何设计一个良好的API。 
12.  如何设计建立和保持100w的长连接。 
13.  解释什么是MESI协议(缓存一致性)。 
14.  说说你知道的几种HASH算法，简单的也可以。 
15.  什么是paxos算法， 什么是zab协议。 
16.  一个在线文档系统，文档可以被编辑，如何防止多人同时对同 
17.  一份文档进行编辑更新。 
18.  线上系统突然变得异常缓慢，你如何查找问题。 
19.  说说你平时用到的设计模式。 
20.  Dubbo的原理，有看过源码么，数据怎么流转的，怎么实现集群，负载均衡，服务注册 
21.  和发现，重试转发，快速失败的策略是怎样的 。 
22.  一次RPC请求的流程是什么。 
23.  自己实现过rpc么，原理可以简单讲讲。Rpc要解决什么问题。 
24.  异步模式的用途和意义。 
25.  编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用。 
26.  设计一个社交网站中的“私信”功能，要求高并发、可扩展等等。 画一下架构图。 
27.  MVC模式，即常见的MVC框架。 
28.  聊下曾经参与设计的服务器架构并画图，谈谈遇到的问题，怎么解决的。 
29.  应用服务器怎么监控性能，各种方式的区别。 
30.  如何设计一套高并发支付方案，架构如何设计。 
31.  如何实现负载均衡，有哪些算法可以实现。 
32.  Zookeeper的用途，选举的原理是什么。 
33.  Zookeeper watch机制原理。 
34.  Mybatis的底层实现原理。 
35.  请思考一个方案，实现分布式环境下的countDownLatch。 
36.  后台系统怎么防止请求重复提交。 
37.  描述一个服务从发布到被消费的详细过程。 
38.  讲讲你理解的服务治理。 
39.  如何做到接口的幂等性。 
40.  如何做限流策略，令牌桶和漏斗算法的使用场景。 
41.  什么叫数据一致性，你怎么理解数据一致性。 
42.  分布式服务调用方，不依赖服务提供方的话，怎么处理服务方挂掉后，大量无效资源请求 
43.  的浪费，如果只是服务提供方吞吐不高的时候该怎么做，如果服务挂了，那么一会重启，该怎 
44.  么做到最小的资源浪费，流量半开的实现机制是什么。 
45.  dubbo的泛化调用怎么实现的，如果是你，你会怎么做。 
46.  远程调用会有超时现象，如果做到优雅的控制，JDK自带的超时机制有哪些，怎么实现的。 

#  算法 

1.  10亿个数字里里面找最小的10个。 
2.  有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优。 
3.  2亿个随机生成的无序整数,找出中间大小的值。 
4.  给一个不知道长度的（可能很大）输入字符串，设计一种方案，将重复的字符排重。 
5.  遍历二叉树。 
6.  有3n+1个数字，其中3n个中是重复的，只有1个是不重复的，怎么找出来。 
7.  写一个字符串（如：[www.javastack.cn](http://www.javastack.cn)）反转函数。 
8.  常用的排序算法，快排，归并、冒泡。 快排的最优时间复杂度，最差复杂度。冒泡排序的 
9.  优化方案。 
10.  二分查找的时间复杂度，优势。 
11.  一个已经构建好的TreeSet，怎么完成倒排序。 
12.  什么是B+树，B-树，列出实际的使用场景。 
13.  一个单向链表，删除倒数第N个数据。 
14.  200个有序的数组，每个数组里面100个元素，找出top20的元素。 
15.  单向链表，查找中间的那个元素。 

#  数据库知识 

1.  数据库隔离级别有哪些，各自的含义是什么，MYSQL默认的隔离级别是是什么。 
2.  什么是幻读。 
3.  MYSQL有哪些存储引擎，各自优缺点。 
4.  高并发下，如何做到安全的修改同一行数据。 
5.  乐观锁和悲观锁是什么，INNODB的标准行级锁有哪2种，解释其含义。 
6.  SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义。 
7.  数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁。 
8.  MYsql的索引原理，索引的类型有哪些，如何创建合理的索引，索引如何优化。 
9.  聚集索引和非聚集索引的区别。 
10.  select for update 是什么含义，会锁表还是锁行或是其他。 
11.  为什么要用Btree实现，它是怎么分裂的，什么时候分裂，为什么是平衡的。 
12.  数据库的ACID是什么。 
13.  某个表有近千万数据，CRUD比较慢，如何优化。 
14.  Mysql怎么优化table scan的。 
15.  如何写sql能够有效的使用到复合索引。 
16.  mysql中in 和exists 区别。 
17.  数据库自增主键可能的问题。 
18.  MVCC的含义，如何实现的。 
19.  你做过的项目里遇到分库分表了吗，怎么做的，有用到中间件么，比如sharding jdbc等,他 
20.  们的原理知道么。 
21.  MYSQL的主从延迟怎么解决。 

#  消息队列 

1.  消息队列的使用场景。 
2.  消息的重发，补充策略。 
3.  如何保证消息的有序性。 
4.  用过哪些MQ，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗，你们公司的MQ服务 
5.  架构怎样的。 
6.  MQ系统的数据如何保证不丢失。 
7.  rabbitmq如何实现集群高可用。 
8.  kafka吞吐量高的原因。 
9.  kafka 和其他消息队列的区别，kafka 主从同步怎么实现。 
10.  利用mq怎么实现最终一致性。 
11.  使用kafka有没有遇到什么问题，怎么解决的。 
12.  MQ有可能发生重复消费，如何避免，如何做到幂等。 
13.  MQ的消息延迟了怎么处理，消息可以设置过期时间么，过期了你们一般怎么处理。 

#  缓存 

1.  常见的缓存策略有哪些，如何做到缓存(比如redis)与DB里的数据一致性，你们项目中用到了 
2.  什么缓存系统，如何设计的。 
3.  如何防止缓存击穿和雪崩。 
4.  缓存数据过期后的更新如何设计。 
5.  redis的list结构相关的操作。 
6.  Redis的数据结构都有哪些。 
7.  Redis的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。 
8.  redis2和redis3的区别，redis3内部通讯机制。 
9.  当前redis集群有哪些玩法，各自优缺点，场景。 
10.  Memcache的原理，哪些数据适合放在缓存中。 
11.  redis和memcached 的内存管理的区别。 
12.  Redis的并发竞争问题如何解决，了解Redis事务的CAS操作吗。 
13.  Redis的选举算法和流程是怎样的。 
14.  redis的持久化的机制，aof和rdb的区别。 
15.  redis的集群怎么同步的数据的。 
16.  知道哪些redis的优化操作。 
17.  Reids的主从复制机制原理。 
18.  Redis的线程模型是什么。 
19.  请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存。 
20.  如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点。 
21.  本地缓存在并发使用时的注意事项。 

#  搜索 

1.  elasticsearch了解多少，说说你们公司es的集群架构，索引数据大小，分片有多少，以及一些 
2.  调优手段 。elasticsearch的倒排索引是什么。 
3.  elasticsearch 索引数据多了怎么办，如何调优，部署。 
4.  elasticsearch是如何实现master选举的。 
5.  详细描述一下Elasticsearch索引文档的过程。 
6.  详细描述一下Elasticsearch搜索的过程。 
7.  Elasticsearch在部署时，对Linux的设置有哪些优化方法？ 
8.  lucence内部结构是什么。